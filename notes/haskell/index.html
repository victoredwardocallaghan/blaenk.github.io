<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Haskell - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' media='screen' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div id="strip"></div>
  <header id="header" class="inner">
    <div id="stamp">
      <h1><a href="/">Jorge Israel Peña</a></h1>
      <h4>AKA BLAENK DENUM</h4>
    </div>
    <nav id="main-nav">
      <ul class="main">
        <li><a href="/about/">About</a></li>
        <li><a href="/work/">Work</a></li>
        <li><a href="/lately/">Lately</a></li>
        <li><a href="/notes/">Notes</a></li>
        <li><a id="search_btn">Search</a></li>
      </ul>
      <form class="desk_search" action="http://google.com/search" method="get">
        <input type="text" name="q" results="0" placeholder="Search... (Click 'Search' to hide)" autocomplete="off" spellcheck="false">
        <input type="hidden" name="q" value="site:blaenkdenum.com">
      </form>
    </nav>
    <nav id="mobile-nav">
      <div class="alignleft menu">
        <a class="button">Menu</a>
        <div class="container">
          <ul class="main">
            <li><a href="/about/">About</a></li>
            <li><a href="/work/">Work</a></li>
            <li><a href="/lately/">Lately</a></li>
            <li><a href="/notes/">Notes</a></li>
            <li><a id="search_btn">Search</a></li>
          </ul>
        </div>
      </div>
      <div class="alignright search">
        <a class="button"></a>
        <div class="container">
          <form action="http://google.com/search" method="get">
            <input type="text" name="q" results="0">
            <input type="hidden" name="q" value="site:blaenkdenum.com">
          </form>
        </div>
      </div>
    </nav>
  </header>
  <div id="content" class="inner">
    <article class="post">
  <h2 class="title"><a href="/notes/haskell/"><span>Haskell</span></a></h2>
  <div class="entry-content"><p>I originally chose <a href="/notes/erlang">Erlang</a> as the first functional programming language to attempt learning. However, the combination of different programming paradigm, obscure Prolog-like syntax, and unfamiliar concurrency paradigm made it particularly difficult for me to see the big picture of functional programming.</p>
<p>I’m actually familiar with Haskell now. This very site is written in Haskell, and I have worked on a few other Haskell projects. That said, Haskell is also a programming language theory (<abbr title="Programming Language Theory">PLT</abbr>) playground. To that end, <abbr title="Glasgow Haskell Compiler">GHC</abbr> contains various Haskell language extensions which I’m not entirely familiar with. This page of notes will therefore not necessarily cover the more basic aspects and instead will cover language extensions, popular libraries, idiomatic patterns, modules, parallelism and concurrency, and so on.</p>
<nav id="toc"><p>Contents</p><ol><li><a href="#parallelism">Parallelism</a><ol><li><a href="#threadscope">ThreadScope</a></li><li><a href="#eval-monad">Eval Monad</a></li><li><a href="#sparks">Sparks</a></li><li><a href="#deepseq">Deepseq</a></li><li><a href="#evaluation-strategies">Evaluation Strategies</a><ol><li><a href="#parameterized-strategies">Parameterized Strategies</a></li></ol></li></ol></li></ol></nav>
<h1 id="parallelism">Parallelism</h1>
<p>Amdahl’s law places an upper bound on potential speedup through more processors. The expected speedup <span class="math">\(S\)</span> can be described as a function of the number of processors <span class="math">\(N\)</span> and the percentage of runtime that can be parallelized <span class="math">\(P\)</span>. The implications are that the potential speedup increasingly becomes negligible with the increase in processors, but more importantly that most programs have a theoretical maximum amount of parallelism.</p>
<p><span class="math">\[S(N) = \frac {1} {(1 - P) + \frac P N}\]</span></p>
<p><img src="/images/notes/haskell/amdahls-law.png" class="center"></p>
<h2 id="threadscope">ThreadScope</h2>
<p>The <a href="http://hackage.haskell.org/package/threadscope">ThreadScope</a> tool helps visualize parallel execution, particularly for profiling. To use ThreadScope, the program should be compiled with the <code>-eventlog</code> <abbr title="Glasgow Haskell Compiler">GHC</abbr> option and then run with the <code>+RTS -l</code> option to generate the eventlog. ThreadScope is then run on this event log:</p>
<figure class="codeblock"><pre><code class="highlight language-bash"><span class="nv">$ </span>ghc -O2 program.hs -threaded -rtsopts -eventlog
<span class="nv">$ </span>./program +RTS -N2 -l
<span class="nv">$ </span>threadscope program.eventlog
</code></pre></figure>
<h2 id="eval-monad">Eval Monad</h2>
<p>The <code>Eval</code> monad from <code>Control.Parallel.Strategies</code> expresses parallelism naturally. The <code>rpar</code> combinator expresses that the argument can be evaluated in parallel, and <code>rseq</code> forces sequential evaluation. Evaluation is to weak head normal form (<abbr title="Weak Head Normal Form">WHNF</abbr>), i.e. the outermost type constructor is evaluated. Notice that the monad is completely pure, with no need for the <code>IO</code> monad.</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="kr">data</span> <span class="kt">Eval</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Eval</span>

<span class="nf">runEval</span> <span class="ow">::</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">rpar</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
<span class="nf">rseq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
</code></pre></figure>
<p>For example, the following evaluates two thunks in parallel then waits for both to be evaluated before returning:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">runEval</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span>
  <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="o">$</span> <span class="n">f</span> <span class="n">y</span>
  <span class="n">rseq</span> <span class="n">a</span>
  <span class="n">rseq</span> <span class="n">b</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></figure>
<p>Consider the following parallelized <code>map</code> implementation:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">parMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">b</span>  <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">bs</span> <span class="ow">&lt;-</span> <span class="n">parMap</span> <span class="n">f</span> <span class="n">as</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">b</span><span class="kt">:</span><span class="n">bs</span><span class="p">)</span>

<span class="nf">runEval</span> <span class="o">$</span> <span class="n">parMap</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></figure>
<h2 id="sparks">Sparks</h2>
<p>An argument to <code>rpar</code> is called a <em>spark</em>. The runtime collects sparks in a pool and distributes them to available processors using a technique known as <em>work stealing</em>. These sparks are to be <em>converted</em>, i.e. evaluated in parallel, though this may fail in a variety of ways. The <code>+RTS -s</code> option provides information about the sparks and what became of them during the execution of the program in the following form:</p>
<figure class="codeblock"><pre><code class="highlight language-text">SPARKS: 100 (100 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)</code></pre></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Term</th>
<th style="text-align: left;">Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">converted</td>
<td style="text-align: left;">successfully evaluated in parallel</td>
</tr>
<tr class="even">
<td style="text-align: left;">overflowed</td>
<td style="text-align: left;">didn’t fit in the spark pool</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dud</td>
<td style="text-align: left;">already evaluated, ignored</td>
</tr>
<tr class="even">
<td style="text-align: left;">GC’d</td>
<td style="text-align: left;">unused, garbage collected</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fizzled</td>
<td style="text-align: left;">evaluated some place else</td>
</tr>
</tbody>
</table>
<h2 id="deepseq">Deepseq</h2>
<p>The <code>Control.Deepseq</code> module contains various utilities for forcing the evaluation of a thunk. It defines the <code>NFData</code>, i.e. <em>normal-form data</em>, type class. This type class has only one method, <code>rnf</code>, i.e. <em>reduce to normal-form</em>, which defines how the particular type may be evaluated to normal form, returning <code>()</code> afterward:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="kr">class</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">rnf</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
  <span class="n">rnf</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="nb">()</span>
</code></pre></figure>
<p>The module also defines a <code>deepseq</code> function which performs a <em>deep</em> evaluation to normal form, similar to <code>seq</code> which performs <em>shallow</em> evaluation to <abbr title="Weak Head Normal Form">WHNF</abbr>. There’s also a more convenient <code>force</code> function which evaluates the argument to normal form and then returns the result.</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">deepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">deepseq</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">rnf</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">b</span>

<span class="nf">force</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">force</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">deepseq</span><span class="p">`</span> <span class="n">x</span>
</code></pre></figure>
<h2 id="evaluation-strategies">Evaluation Strategies</h2>
<p>Evaluation strategies decouple algorithms from parallelism, allowing for parallelizing in different ways by substituting a different strategy. A <code>Strategy</code> is a function in <code>Eval</code> that returns its argument.</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="kr">type</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>
</code></pre></figure>
<p>A strategy would take a data structure as input which is then traversed and evaluated with parallelism and returns the original value. For example a strategy for evaluating a pair tuple could look like:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">parPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">parPair</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">a&#39;</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="n">a</span>
  <span class="n">b&#39;</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="n">b</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span> <span class="n">b&#39;</span><span class="p">)</span>
</code></pre></figure>
<p>This strategy could then be used either directly or using the <code>using</code> combinator, which reads as <em>use this expression by evaluating it with this strategy</em>:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">using</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">runEval</span> <span class="p">(</span><span class="n">s</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">runEval</span> <span class="o">.</span> <span class="n">parPair</span> <span class="o">$</span> <span class="p">(</span><span class="n">fib</span> <span class="mi">35</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">36</span><span class="p">)</span>
<span class="p">(</span><span class="n">fib</span> <span class="mi">35</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">36</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parPair</span>
</code></pre></figure>
<h3 id="parameterized-strategies">Parameterized Strategies</h3>
<p>The <code>parPair</code> always evaluates the pair components in parallel and always to <abbr title="Weak Head Normal Form">WHNF</abbr>. A parameterized strategy could take as arguments strategies to apply to the type’s components. The following <code>evalPair</code> function is so called because it no longer assume parallelism, instead delegating that decision to the passed in strategy.</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">evalPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">evalPair</span> <span class="n">sa</span> <span class="n">sb</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">a&#39;</span> <span class="ow">&lt;-</span> <span class="n">sa</span> <span class="n">a</span>
  <span class="n">b&#39;</span> <span class="ow">&lt;-</span> <span class="n">sb</span> <span class="n">b</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a&#39;</span><span class="p">,</span> <span class="n">b&#39;</span><span class="p">)</span>
</code></pre></figure>
<p>It’s then possible to define a <code>parPair</code> function in terms of <code>evalPair</code> that evaluates the pair’s components in parallel. However, the <code>rpar</code> strategy only evaluates to <abbr title="Weak Head Normal Form">WHNF</abbr>, restricting the evaluation strategy. We could instead use <code>rdeepseq</code> — a strategy to evaluate to normal form — by wrapping <code>rdeepseq</code> with <code>rpar</code>. The <code>rparWith</code> combinator allows the wrapping of strategies in this manner:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">rdeepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rdeepseq</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">rseq</span> <span class="p">(</span><span class="n">force</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">rparWith</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>

<span class="nf">parPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">parPair</span> <span class="n">sa</span> <span class="n">sb</span> <span class="ow">=</span> <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">sa</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">sb</span><span class="p">)</span>
</code></pre></figure>
<p>This then allows us to use <code>parPair</code> to create a strategy that evaluates a pair tuple to normal form, which can then be used with the <code>using</code> combinator:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="p">(</span><span class="n">fib</span> <span class="mi">35</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">36</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parPair</span> <span class="n">rdeepseq</span> <span class="n">rdeepseq</span>
</code></pre></figure>
<p>Sometimes it may be required to not evaluate certain type components, which can be accomplished using the <code>r0</code> strategy. For example, the following evaluates only the first components of a pair of pairs, i.e. <code>a</code> and <code>c</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">r0</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">r0</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">x</span>

<span class="nf">evalPair</span> <span class="p">(</span><span class="n">evalPair</span> <span class="n">rpar</span> <span class="n">r0</span><span class="p">)</span> <span class="p">(</span><span class="n">evalPair</span> <span class="n">rpar</span> <span class="n">r0</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
</code></pre></figure>
<p>The <code>parMap</code> function can be defined in terms of evaluation strategies. The <code>parList</code> function is a strategy that evaluates list elements in parallel. Defining <code>parList</code> can take the same approach as before: define a parameterized strategy on lists called <code>evalList</code> and then define a parameterized function <code>parList</code> that performs <code>evalList</code> in parallel. Both of these functions are already defined in <code>Control.Parallel.Strategies</code>:</p>
<figure class="codeblock"><pre><code class="highlight language-haskell"><span class="nf">evalList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">evalList</span> <span class="n">strat</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">evalList</span> <span class="n">strat</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x&#39;</span>  <span class="ow">&lt;-</span> <span class="n">strat</span> <span class="n">x</span>
  <span class="n">xs&#39;</span> <span class="ow">&lt;-</span> <span class="n">evalList</span> <span class="n">strat</span> <span class="n">xs</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">x&#39;</span><span class="kt">:</span><span class="n">xs&#39;</span><span class="p">)</span>

<span class="nf">parList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parList</span> <span class="n">strat</span> <span class="ow">=</span> <span class="n">evalList</span> <span class="o">$</span> <span class="n">rparWith</span> <span class="n">strat</span>

<span class="nf">parMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span>
</code></pre></figure></div>
  <div class="meta">
    <div class="date"><i class="fa fa-calendar fa-fw"></i> March  5, 2014</div>
    <div class="notes"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
    <div class="commit"><i class="fa fa-code-fork fa-fw"></i> <a href='https://github.com/blaenk/blaenk.github.io/commits/source/provider/notes/haskell.markdown'>History</a><span class='hash'>, <a href='https://github.com/blaenk/blaenk.github.io/commit/da1ed04' title='newline separation'>da1ed04</a></span></div>
  </div>
</article>


  </div>
  <footer id="footer" class="inner">
    <span id="social">
      <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
      &middot;
      <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
      &middot;
      <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
      &middot;
      <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
      &middot;
      <a href="/atom.xml" title="feed"><i class="fa fa-rss-square"></i></a>
    </span>
  </footer>
  
  
  <!-- google analytics -->
  <script async="true" type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37339861-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <!--MathJax CDN-->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      messageStyle: "none"
    });

    MathJax.Hub.Register.MessageHook('End Process', function() {
      jQuery('#MathJax_Font_Test').empty();
      jQuery('.MathJax_Display').parent('.math').addClass('mobile-math');
    });
  </script>
  <script async="true" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  </script>
</body>
</html>
