<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <title>Algorithms - Blaenk Denum</title>
  <meta name="author" content="Jorge Israel Peña">
  <meta name="description" content="AKA Blaenk Denum">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/favicon.png" rel="shortcut icon">
  <link href='http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Merriweather:900italic,900,700italic,400italic,700,400,300italic,300' rel='stylesheet' type='text/css'>
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.css" rel="stylesheet">
  <link href='/css/screen.css' rel='stylesheet' type='text/css' media='screen' />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src='/js/blaenk.js' type='text/javascript'></script>
</head>
<body>
  <div id="strip"></div>
  <header id="header" class="inner">
    <div id="stamp">
      <h1><a href="/">Jorge Israel Peña</a></h1>
      <h4>AKA BLAENK DENUM</h4>
    </div>
    <nav id="main-nav">
      <ul class="main">
        <li><a href="/about/">About</a></li>
        <li><a href="/work/">Work</a></li>
        <li><a href="/lately/">Lately</a></li>
        <li><a href="/notes/">Notes</a></li>
        <li><a id="search_btn">Search</a></li>
      </ul>
      <form class="desk_search" action="http://google.com/search" method="get">
        <input type="text" name="q" results="0" placeholder="Search... (Click 'Search' to hide)" autocomplete="off" spellcheck="false">
        <input type="hidden" name="q" value="site:blaenkdenum.com">
      </form>
    </nav>
    <nav id="mobile-nav">
      <div class="alignleft menu">
        <a class="button">Menu</a>
        <div class="container">
          <ul class="main">
            <li><a href="/about/">About</a></li>
            <li><a href="/work/">Work</a></li>
            <li><a href="/lately/">Lately</a></li>
            <li><a href="/notes/">Notes</a></li>
            <li><a id="search_btn">Search</a></li>
          </ul>
        </div>
      </div>
      <div class="alignright search">
        <a class="button"></a>
        <div class="container">
          <form action="http://google.com/search" method="get">
            <input type="text" name="q" results="0">
            <input type="hidden" name="q" value="site:blaenkdenum.com">
          </form>
        </div>
      </div>
    </nav>
  </header>
  <div id="content" class="inner">
    <article class="post">
  <h2 class="title"><a href="/notes/algorithms/"><span>Algorithms</span></a></h2>
  <div class="entry-content"><p>What follows are some notes on algorithms I’ve been reviewing from <a href="http://amzn.com/032157351X">Algorithms</a> by Robert Sedgewick and Kevin Wayne, <a href="http://amzn.com/1849967202">The Algorithm Design Manual</a> by Steven S. Skiena, and other sources around the Internet <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. I wanted to write some notes on the material so that I could easily look back on it, but mainly so that I could be sure that I understand the material — since I have to understand it to explain it.</p>
<nav id="toc"><p>Contents</p><ol><li><a href="#dynamic-connectivity">Dynamic Connectivity</a><ol><li><a href="#quick-find">Quick-Find</a></li><li><a href="#quick-union">Quick-Union</a></li><li><a href="#weighted-quick-union">Weighted Quick-Union</a><ol><li><a href="#path-compression">Path Compression</a></li></ol></li></ol></li><li><a href="#sorting">Sorting</a><ol><li><a href="#selection-sort">Selection Sort</a></li><li><a href="#insertion-sort">Insertion Sort</a></li><li><a href="#shell-sort">Shell Sort</a></li><li><a href="#merge-sort">Merge Sort</a><ol><li><a href="#top-down">Top-Down</a><ol><li><a href="#merge-sort-improvements">Improvements</a></li></ol></li><li><a href="#bottom-up">Bottom-Up</a></li></ol></li><li><a href="#quick-sort">Quick Sort</a><ol><li><a href="#quick-sort-improvements">Improvements</a></li><li><a href="#three-way-partitioning">Three-way Partitioning</a></li></ol></li><li><a href="#priority-queues">Priority Queues</a><ol><li><a href="#priority-queue-data-structure">Data Structure</a><ol><li><a href="#priority-queue-insertion">Insertion</a></li><li><a href="#priority-queue-removal">Removal</a></li></ol></li><li><a href="#heap-sort">Heap Sort</a></li></ol></li><li><a href="#selection">Selection</a></li></ol></li><li><a href="#searching">Searching</a><ol><li><a href="#binary-search-trees">Binary Search Trees</a><ol><li><a href="#binary-search-tree-traversal">Traversal</a></li><li><a href="#binary-search-tree-deletion">Deletion</a></li></ol></li><li><a href="#two-three-search-trees">2-3 Search Trees</a><ol><li><a href="#two-three-tree-searching">Searching</a></li><li><a href="#two-three-tree-insertion">Insertion</a></li></ol></li><li><a href="#red-black-trees">Red-Black Trees</a><ol><li><a href="#red-black-tree-insertion">Insertion</a></li><li><a href="#red-black-tree-deletion">Deletion</a><ol><li><a href="#red-black-tree-deletion-balance">Balance</a></li></ol></li></ol></li><li><a href="#interval-trees">Interval Trees</a><ol><li><a href="#intersection-queries">Intersection Queries</a></li></ol></li><li><a href="#hash-tables">Hash Tables</a><ol><li><a href="#hash-functions">Hash Functions</a></li><li><a href="#separate-chaining">Separate Chaining</a></li><li><a href="#linear-probing">Linear Probing</a><ol><li><a href="#hash-table-deletion">Deletion</a></li><li><a href="#hash-table-load-factor">Load Factor</a></li></ol></li><li><a href="#sparse-vectors">Sparse Vectors</a></li></ol></li></ol></li><li><a href="#graphs">Graphs</a><ol><li><a href="#undirected-graphs">Undirected Graphs</a><ol><li><a href="#depth-first-search">Depth-First Search</a></li><li><a href="#breadth-first-search">Breadth-First Search</a></li><li><a href="#connected-components">Connected Components</a></li><li><a href="#cycle-detection">Cycle Detection</a></li><li><a href="#bipartite-detection">Bipartite Detection</a></li></ol></li><li><a href="#directed-graphs">Directed Graphs</a><ol><li><a href="#digraph-reachability">Reachability</a></li><li><a href="#directed-cycle-detection">Cycle Detection</a></li><li><a href="#topological-order">Topological Order</a></li><li><a href="#strong-connectivity">Strong Connectivity</a></li><li><a href="#all-pairs-reachability">All-Pairs Reachability</a></li></ol></li><li><a href="#minimum-spanning-trees">Minimum Spanning Trees</a><ol><li><a href="#prims-algorithm">Prim’s Algorithm</a><ol><li><a href="#eager-prims">Eager Prim’s Algorithm</a></li></ol></li><li><a href="#kruskals-algorithm">Kruskal’s Algorithm</a></li></ol></li><li><a href="#shortest-paths">Shortest Paths</a><ol><li><a href="#dijkstras-algorithm">Dijkstra’s Algorithm</a></li><li><a href="#topological-sort">Topological Sort</a></li><li><a href="#parallel-job-scheduling">Parallel Job Scheduling</a></li><li><a href="#bellman-ford-algorithm">Bellman-Ford Algorithm</a></li></ol></li></ol></li><li><a href="#strings">Strings</a><ol><li><a href="#string-sorting">Sorting</a><ol><li><a href="#counting-sort">Counting Sort</a></li><li><a href="#least-significant-digit-sort">Least Significant Digit Sort</a></li><li><a href="#most-significant-digit-sort">Most Significant Digit Sort</a></li><li><a href="#three-way-string-quicksort">Three-way String QuickSort</a></li></ol></li><li><a href="#tries">Tries</a><ol><li><a href="#trie-deletion">Deletion</a></li><li><a href="#ternary-search-trees">Ternary Search Trees</a></li></ol></li><li><a href="#substring-search">Substring Search</a><ol><li><a href="#brute-force-substring-search">Brute-Force</a></li><li><a href="#knuth-morris-pratt">Knuth-Morris-Pratt</a><ol><li><a href="#kmp-dfa-composition">DFA Composition</a></li><li><a href="#kmp-prevent-backtracking">Preventing Backtracking</a></li><li><a href="#kmp-dfa-construction">DFA Construction</a></li><li><a href="#kmp-search">KMP Search</a></li></ol></li><li><a href="#boyer-moore">Boyer-Moore</a><ol><li><a href="#bm-skip-table">Skip Table</a></li><li><a href="#bm-search">Search</a></li></ol></li><li><a href="#rabin-karp">Rabin-Karp</a></li></ol></li><li><a href="#regular-expressions">Regular Expressions</a><ol><li><a href="#regex-match-checking">Match Checking</a></li><li><a href="#regex-nfa-construction">NFA Construction</a></li></ol></li><li><a href="#data-compression">Data Compression</a><ol><li><a href="#run-length-encoding">Run-Length Encoding</a></li><li><a href="#huffman-compression">Huffman Compression</a></li><li><a href="#lzw-compression">LZW Compression</a></li></ol></li></ol></li><li><a href="#context">Context</a><ol><li><a href="#b-trees">B-Trees</a><ol><li><a href="#b-tree-insertion">Insertion</a></li></ol></li><li><a href="#suffix-arrays">Suffix Arrays</a></li><li><a href="#network-flow">Network-Flow</a><ol><li><a href="#ford-fulkerson">Ford-Fulkerson</a></li></ol></li><li><a href="#np-complete-problems">NP-Complete Problems</a></li></ol></li></ol></nav>
<h1 id="dynamic-connectivity">Dynamic Connectivity</h1>
<p><strong>Answers</strong>: Is a pair of nodes connected?</p>
<p><strong>Data Structure</strong>: Array, indexed by any given site to the value corresponding to the component its a part of: <code>id[site] = component</code>. All sites are initially set to be members of their own component — i.e. <code>id[5] = 5</code>.</p>
<p><strong>General Flow</strong>: Sites are all partitioned into singleton sets. Successive <code>union()</code> operations merge sets together. The <code>find()</code> operation determines if a given pair of sites are from the same component.</p>
<p>A <strong>site</strong> is an element or node in a disjoint set. The disjoint set is known as a <strong>component</strong>, which typically models a set or graph. Two sites are <strong>connected</strong> if they are part of the same component.</p>
<h2 id="quick-find">Quick-Find</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th style="text-align: center;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Find</td>
<td style="text-align: center;"><span class="math">\(O(1)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Union</td>
<td style="text-align: center;"><span class="math">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This algorithm favors a quick <code>find()</code> operation by sacrificing the <code>union()</code> operation.</p>
<p>Union operates as follows:</p>
<ol type="1">
<li>of the two sites <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>, <em>arbitrarily</em> choose one to merge under the other</li>
<li>gets the associated components of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span></li>
<li>goes through the whole array, setting sites which were part of <span class="math">\(P\)</span>’s component to now be part of <span class="math">\(Q\)</span>’s</li>
<li>decrements the number of components in the disjoint-set</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">site</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">site</span><span class="o">];</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">pID</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">qID</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">pID</span> <span class="o">==</span> <span class="n">qID</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">id</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">pID</span><span class="o">)</span> <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">qID</span><span class="o">;</span>

  <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre><figcaption><span>quick-find</span></figcaption></figure>
<h2 id="quick-union">Quick-Union</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th style="text-align: center;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Find</td>
<td style="text-align: center;"><span class="math">\(\text{tree height}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Union</td>
<td style="text-align: center;"><span class="math">\(\text{tree height}\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This algorithm aims to speed up the <code>union()</code> operation by avoiding the act of going through the whole array to change the component of every affected site.</p>
<p>This is accomplished by creating a tree-like relationship between sites. With a tree representation, sites are added as direct leaves to the root node of the component to which they were merged.</p>
<p>As a result of this, the <code>find()</code> operation needs to walk up the tree from any given site to find the root note which designates the component to which the given site belongs to. The walk is terminated when it encounters a site whose component is itself.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="n">p</span> <span class="o">=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
  <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>

  <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre><figcaption><span>quick-union</span></figcaption></figure>
<h2 id="weighted-quick-union">Weighted Quick-Union</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th style="text-align: center;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Find</td>
<td style="text-align: center;"><span class="math">\(\lg(n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Union</td>
<td style="text-align: center;"><span class="math">\(\lg(n)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The problem with vanilla Quick-Union is that the trees are merged arbitrarily. This can cause bad performance depending on which tree is merged under the other.</p>
<p>Given the arbitrary form in which components are merged in Quick-Union, input of the form 0-1, 0-2, 0-3, … 0-N can have worst-case effects:</p>
<ol type="1">
<li>0-1 can connect component 0 under component 1</li>
<li>0-2 can connect component 1 under component 2</li>
<li>0-3 can connect component 2 under component 3</li>
</ol>
<p>This input eventually creates a linked-list, where the deepest node in the tree incurs the cost of having to traverse the entire list of sites before determining the component to which it belongs.</p>
<p>Weighted Quick-Union fixes this by keeping track of each component’s size in a separate array. With this information it then chooses to merge the smaller component under the larger one.</p>
<p>In the example above, by step 2, component 1 is size 2, so component 2, being size 1, is merged under component 1 and not the other way around.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span> <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="n">sz</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">}</span>
  <span class="k">else</span>               <span class="o">{</span> <span class="n">id</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">[</span><span class="n">j</span><span class="o">];</span> <span class="o">}</span>

  <span class="n">count</span><span class="o">--;</span>
<span class="o">}</span>
</code></pre><figcaption><span>weighted quick-union</span></figcaption></figure>
<h3 id="path-compression">Path Compression</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operation</th>
<th style="text-align: center;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Union</td>
<td style="text-align: center;"><span class="math">\(\approx 1\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>A further improvement can be done called <strong>path compression</strong> in which every site traversed due to a call to <code>find()</code> is directly linked to the component root.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">])</span>
    <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">]);</span>

  <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>
<span class="o">}</span>
</code></pre><figcaption><span>path compression</span></figcaption></figure>
<h1 id="sorting">Sorting</h1>
<p>Many problems can be reduced to sorting.</p>
<p><strong>Answers</strong>: Ordering a sequence into a specified order.</p>
<p><strong>Data Structure</strong>: Array or other sequence.</p>
<p>The following algorithms are described with the assumption that the sequence is an array of contiguous memory and constant access time. This is <strong>noteworthy</strong> because it is important to recognize algorithms can have different speeds depending on the underlying data structure.</p>
<p>For example, selection sort backed by a priority queue or balanced binary tree can help to speed up the operation of finding the smallest element in the unsorted region. Instead of being linear, the operation would be <span class="math">\(\lg(n)\)</span>. Given that this is done at every element in the sequence, of which there are <span class="math">\(N\)</span>, this means that selection sort backed by such a structure can be improved from <span class="math">\(O(n^2)\)</span> to <span class="math">\(O(n\lg(n))\)</span> <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<p>A sorting algorithm is known as <strong>stable</strong> if it maintains the same relative order of equal keys as it was before the sorting operation.</p>
<h2 id="selection-sort">Selection Sort</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math">\(\Theta(n^2)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This is a pretty naive algorithm that is mainly useful for didactic purposes.</p>
<p>Algorithm operation:</p>
<ol type="1">
<li>go through entire sequence to find smallest element</li>
<li>swap element with the left-most unsorted element</li>
<li>repeat until the end of the sequence</li>
</ol>
<p>This essentially splits the sequence into a left sorted region and a right unsorted region.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">min</span><span class="o">])</span> <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>

    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">min</span><span class="o">]);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>selection sort <a href="http://www.sorting-algorithms.com/selection-sort">visualize</a></span></figcaption></figure>
<h2 id="insertion-sort">Insertion Sort</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Best</td>
<td style="text-align: left;"><span class="math">\(\Theta(n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n^2)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This is a <strong>stable</strong> algorithm that is still pretty straightforward but somewhat improves upon selection sort if the array is already sorted or if it’s nearly sorted.</p>
<p>It operates as follows:</p>
<ol type="1">
<li>go through the entire sequence until an element is found which is <strong>smaller than the previous element</strong></li>
<li>swap the smaller element with the one on the left until the element to its left is no longer larger than itself</li>
<li>repeat until the end of the sequence</li>
</ol>
<p>The benefit of insertion sort is that if the sequence is already sorted then the algorithm operates in linear time. Similarly, if the sequence is nearly sorted, the algorithm will perform better than the worst case.</p>
<p><strong>Performance Factors</strong>: order of the items</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span> <span class="n">j</span><span class="o">--)</span>
      <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre><figcaption><span>insertion sort <a href="http://www.sorting-algorithms.com/insertion-sort">visualize</a></span></figcaption></figure>
<h2 id="shell-sort">Shell Sort</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n^{3/_2})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>While insertion sort can be faster than selection sort, one problem with it is that the swap operations are done one at a time. This means that in the worst case, when sorting position 1 of the array, the smallest element could be at the very end of the array, meaning a total of <span class="math">\(N - 1\)</span> swaps where <span class="math">\(N\)</span> is the length of the array.</p>
<p>Shell sort aims to mitigate this by doing the following:</p>
<ol type="1">
<li>pick a large number <span class="math">\(H\)</span> some constant factor less than the length of the sequence</li>
<li>consider every <span class="math">\(H^{th}\)</span> element in the sequence and apply insertion sort to those elements</li>
<li>now consider every <span class="math">\((H + 1)^{th}\)</span> element and do the same</li>
<li>repeat incrementing <span class="math">\(H\)</span> until the end of the array is reached</li>
<li>repeat steps 2 - 4 but with <span class="math">\(H\)</span> reduced by some factor until the reduction reaches <span class="math">\(1\)</span></li>
<li>ultimately do regular insertion sort, i.e. <span class="math">\(H = 1\)</span></li>
</ol>
<p>The value picked for <span class="math">\(H\)</span> and the factor which is used to reduce it form what is known as a <a href="http://en.wikipedia.org/wiki/Shellsort#Gap_sequences">gap sequence</a>. The overall worst-case time complexity <strong>depends on the chosen gap sequence</strong>. A commonly chosen gap sequence with a worst-case time complexity of <span class="math">\(O(n^{3/_2})\)</span> is:</p>
<p><span class="math">\[\frac {(3^k - 1)} {2} \text{, not greater than}\ \lceil N/3 \rceil\]</span></p>
<p>This sequence begins at the largest increment less than <span class="math">\(N/3\)</span> and decreases to 1. This means that for a sequence of length <span class="math">\(16\)</span> the sequence is <span class="math">\(13, 4, 1\)</span>.</p>
<p>The effect of shell sort is that it sorts elements that are <span class="math">\(H\)</span> elements apart with one swap instead of <span class="math">\(H\)</span>. The granularity of the sorting operation increases as <span class="math">\(H\)</span> itself decreases such that every element is eventually sorted, but with the added benefit that as <span class="math">\(H\)</span> decreases, the distance of the longest-distance swap decreases.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">/</span><span class="mi">3</span><span class="o">)</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="o">];</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">h</span><span class="o">)</span>
        <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>shell sort <a href="http://www.sorting-algorithms.com/shell-sort">visualize</a></span></figcaption></figure>
<h2 id="merge-sort">Merge Sort</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n\lg{n})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This is a <strong>stable</strong> algorithm and the first algorithm that is linearithmic in complexity. The general idea is that the sequence is split into many pieces and then they’re all merged back together. The sorting occurs during the merging phase. The merging algorithm works such that the resultant merged piece is sorted.</p>
<p>The main drawback is that it has <span class="math">\(O(n)\)</span> space complexity because an auxiliary sequence has to be created to facilitate the merging process.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
    <span class="n">aux</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
    <span class="k">if</span>      <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">)</span>         <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">hi</span><span class="o">)</span>          <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>
    <span class="k">else</span>                      <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
<span class="o">}</span>
</code></pre><figcaption><span>merge algorithm</span></figcaption></figure>
<h3 id="top-down">Top-Down</h3>
<p>This is a recursive approach that works by splitting the array into two pieces until the pieces consist of pairs of elements. On each recurrence, the two pieces that were split for that recurrence are merged back.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

  <span class="n">merge</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>merge sort – top-down</span></figcaption></figure>
<h4 id="merge-sort-improvements">Improvements</h4>
<p>There are a couple of improvements that can be made to top-down merge sort:</p>
<ul>
<li><strong>use insertion sort for small sub-arrays</strong>: create a cut-off, e.g. 15 elements, where the pieces are sorted with insertion sort instead of being broken down further</li>
<li><strong>test if sequence is already in order</strong>: skip the merging phase if <code>seq[mid] &lt;= seq[mid + 1]</code></li>
</ul>
<h3 id="bottom-up">Bottom-Up</h3>
<p>The other approach to merge sort is bottom-up, that is, starting with arrays consisting of one element and merging them together, then merging all of the arrays of size two, and so on until the entire array is merged.</p>
<ol type="1">
<li>increments a counter <span class="math">\(SZ\)</span> in the series of powers of two until <span class="math">\(SZ &lt; N\)</span></li>
<li>merges every sub-array of length <span class="math">\(2SZ\)</span></li>
</ol>
<p>One <strong>advantage</strong> of bottom-up merge sort is that it can be modified to perform on linked-lists <strong>in place</strong>.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">sz</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="n">sz</span><span class="o">;</span> <span class="n">lo</span> <span class="o">+=</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span><span class="o">)</span>
      <span class="n">merge</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">min</span><span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>
</code></pre><figcaption><span>merge sort – bottom-up</span></figcaption></figure>
<h2 id="quick-sort">Quick Sort</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n\lg{n})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(\lg{n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This is a divide-and-conquer algorithm that works by essentially partitioning the array into two sub-arrays and sorting them independently. It is typically faster than merge sort because it does less data movement.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">shuffle</span><span class="o">(</span><span class="n">seq</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>quick sort <a href="http://www.sorting-algorithms.com/quick-sort">visualize</a></span></figcaption></figure>
<p>The partition algorithm is similar to merge in merge sort in that it is what actually does the sorting.</p>
<p><img class="center" src="/images/notes/algorithms/quicksort/partition.png"></p>
<ol type="1">
<li>choose a partition element separator <span class="math">\(v\)</span></li>
<li>scan through the array from <span class="math">\(i\)</span> to <span class="math">\(j\)</span> in both directions
<ol type="1">
<li>while <span class="math">\(i &lt; v\)</span> do <code>i++</code></li>
<li>while <span class="math">\(j &gt; v\)</span> do <code>j--</code></li>
<li>swap <span class="math">\(i\)</span> and <span class="math">\(j\)</span></li>
</ol></li>
<li>repeat step 2 until the iterators <span class="math">\(i\)</span> and <span class="math">\(j\)</span> cross</li>
<li>swap the partition element <span class="math">\(v\)</span> with the final position of the right-side iterator <span class="math">\(j\)</span></li>
</ol>
<p>The sorting algorithm then recurses on the two partitions.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">private</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="n">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>

  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">seq</span><span class="o">[++</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">v</span>       <span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">v</span>        <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[--</span><span class="n">j</span><span class="o">])</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">lo</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
  <span class="o">}</span>

  <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">lo</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
  <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>partition algorithm</span></figcaption></figure>
<h3 id="quick-sort-improvements">Improvements</h3>
<ul>
<li><p><strong>use insertion sort for small sub-arrays</strong>: Adding a cutoff size for which to apply insertion sort to small sub-arrays can improve the performance of the algorithm.</p>
<p>Instead of:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
</code></pre></figure>
<p>use:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span> <span class="n">insertionSort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>
</code></pre></figure>
<p>where <code>M</code> is the cutoff. Recommended sizes are between 5 and 15.</p></li>
<li><p><strong>median-of-three partitioning</strong>: Choose a sample of size 3 from the sequence and choose the middle element as the partitioning element.</p></li>
</ul>
<h3 id="three-way-partitioning">Three-way Partitioning</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Best</td>
<td style="text-align: left;"><span class="math">\(O(n)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n\lg{n})\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(\lg{n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>One problem with quick sort as it is implemented above is that items with keys equal to that of the partition item are nonetheless swapped, unnecessarily. Three-way partitioning aims to resolve this by partitioning into three separate sub-arrays, the middle of which corresponds to those items with keys equal to the partition point. E. W. Dijkstra popularized this as the <em>Dutch National Flag</em> problem.</p>
<p><strong>Performance Factors</strong>: distribution of the keys</p>
<p><img class="center" src="/images/notes/algorithms/quicksort/3waypartition.png"></p>
<ol type="1">
<li>perform a 3-way comparison between element <span class="math">\(i\)</span> and <span class="math">\(v\)</span>
<ol type="1">
<li><span class="math">\(seq[i] &lt; v\)</span>: swap <span class="math">\(lt\)</span> and <span class="math">\(i\)</span> and <code>lt++</code> and <code>i++</code></li>
<li><span class="math">\(seq[i] &gt; v\)</span>: swap <span class="math">\(i\)</span> and <span class="math">\(gt\)</span> and <code>gt--</code></li>
<li><span class="math">\(seq[i] = v\)</span>: <code>i++</code></li>
</ol></li>
<li>repeat step 1 until <span class="math">\(i\)</span> and <span class="math">\(gt\)</span> cross, i.e. while <span class="math">\(i \leq gt\)</span></li>
<li>recurse on the left and right segments</li>
</ol>
<p>Quick sort performs a lot better than merge sort in sequences that have duplicate keys. Its time is reduced from linearithmic to linear for sequences with large numbers of duplicate keys.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
  <span class="n">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">seq</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">-</span> <span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>

    <span class="k">if</span>      <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">lt</span><span class="o">++],</span> <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">++]);</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">],</span>    <span class="n">seq</span><span class="o">[</span><span class="n">gt</span><span class="o">--]);</span>
    <span class="k">else</span>              <span class="n">i</span><span class="o">++;</span>
  <span class="o">}</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">gt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>three-way partitioning</span></figcaption></figure>
<h2 id="priority-queues">Priority Queues</h2>
<p>A priority queue is an abstract data type that allows adding elements and retrieving the smallest or largest element. Priority queues are useful for an unbounded sequence for which we want to retrieve the <span class="math">\(M\)</span> smallest elements at any given moment.</p>
<h3 id="priority-queue-data-structure">Data Structure</h3>
<p>The data structure commonly used to back a priority queue is an array, with the first element <code>seq[0]</code> unused, embedding the contents of a <strong>complete binary tree</strong> in level-order that maintains two invariants:</p>
<ol type="1">
<li>the parent of <span class="math">\(k\)</span> is <span class="math">\(k / 2\)</span></li>
<li>the children of <span class="math">\(k\)</span> are at <span class="math">\(2k\)</span> and <span class="math">\(2k + 1\)</span></li>
</ol>
<h4 id="priority-queue-insertion">Insertion</h4>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(\lg{n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>To insert into the heap:</p>
<ol type="1">
<li>add element to the end of the array</li>
<li>increment heap size</li>
<li>swim up the heap to restore heap order</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">])</span> <span class="o">{</span>
    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">]);</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>swim</span></figcaption></figure>
<h4 id="priority-queue-removal">Removal</h4>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(\lg{n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>To remove the maximum from the heap:</p>
<ol type="1">
<li>take the largest item off of the top</li>
<li>put the item from the end of the heap at the top</li>
<li>decrement heap size</li>
<li>sink down the heap to restore heap order</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="n">j</span><span class="o">++;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">j</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>sink</span></figcaption></figure>
<h3 id="heap-sort">Heap Sort</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n\lg{n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Heap sort is a sorting algorithm facilitated by a priority queue which performs well when backed by a binary heap. Heap sort more or less amounts to:</p>
<ol type="1">
<li>feeding the sequence into a priority queue</li>
<li>extracting the sequence out of the priority queue</li>
</ol>
<p>However, there are certain details involved to make it operate faster. Usually these operations are performed in place to avoid using extra space.</p>
<p>First, the sequence has to be put into heap order, which is accomplished by walking up the tree (bottom-up) and sinking every root node with more than one child. The starting point for this is always <span class="math">\(N / 2\)</span>.</p>
<p>Assuming a maximum-oriented priority queue, the sorting is then accomplished by:</p>
<ol type="1">
<li>remove the maximum, thus decrementing the heap size</li>
<li>swap the maximum with the last item in the heap</li>
<li>sink the new root</li>
<li>repeat 1-3 until the priority queue becomes empty</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">--)</span>
    <span class="n">sink</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">N</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">swap</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">seq</span><span class="o">[</span><span class="n">N</span><span class="o">--]);</span>
    <span class="n">sink</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>heap sort</span></figcaption></figure>
<h2 id="selection">Selection</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Average</td>
<td style="text-align: left;"><span class="math">\(\Theta(n)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Selecting the <span class="math">\(k\)</span> smallest items in a sequence can be accomplished by using the quick sort algorithm’s partition algorithm. This is guaranteed by the invariant held by quick sort’s partition algorithm which states that given the partition index <span class="math">\(j\)</span>, all elements to the left are less than or equal to <span class="math">\(j\)</span> and all elements to the right are greater than or equal to <span class="math">\(j\)</span>, effectively making the sub-sequence up to <span class="math">\(j\)</span> consist of the smallest <span class="math">\(j\)</span> elements in the sequence.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">public</span> <span class="n">Comparable</span> <span class="nf">select</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">seq</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">shuffle</span><span class="o">(</span><span class="n">seq</span><span class="o">);</span>

  <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&gt;</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">seq</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>

    <span class="k">if</span>      <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="k">return</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="k">else</span> <span class="nf">if</span>  <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="nf">if</span>  <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">seq</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
<span class="o">}</span>
</code></pre><figcaption><span>selection</span></figcaption></figure>
<h1 id="searching">Searching</h1>
<p><strong>Answers</strong>: Finding a certain element in a collection.</p>
<h2 id="binary-search-trees">Binary Search Trees</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(n)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This is the classical data structure consisting of a binary tree where each node has two children. The sub-tree to the left of each node consists of elements smaller than the node and the sub-tree to the right of each node consists of elements greater than the node.</p>
<p>The performance of <abbr title="Binary Search Trees">BST</abbr>s greatly depends on the shape of the tree, which is a result of the distribution and order of the elements that are input.</p>
<h4 id="binary-search-tree-traversal">Traversal</h4>
<p>There are three main forms of traversing a <abbr title="Binary Search Trees">BST</abbr>. The <em>order</em> refers to the order in which the current node <span class="math">\(C\)</span> is visited, that is, the time at which <span class="math">\(C\)</span> is visited is the only thing that varies, so <span class="math">\(L\)</span> is always visited before <span class="math">\(R\)</span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Traversal</th>
<th style="text-align: left;">Order</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">pre-order</td>
<td style="text-align: left;"><span class="math">\(C \to L \to R\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">in-order</td>
<td style="text-align: left;"><span class="math">\(L \to C \to R\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">post-order</td>
<td style="text-align: left;"><span class="math">\(L \to R \to C\)</span></td>
</tr>
</tbody>
</table>
<h4 id="binary-search-tree-deletion">Deletion</h4>
<p>Most operations such as insertion and lookup are very straightforward. Deletion is somewhat more involved.</p>
<p>To delete node <span class="math">\(z\)</span>:</p>
<ol type="1">
<li><span class="math">\(z\)</span> <strong>has no children</strong>: transplant it with a child, which is <span class="math">\(nil\)</span></li>
<li><span class="math">\(z\)</span> <strong>has just one child</strong>: transplant it with the child</li>
<li><span class="math">\(z\)</span> <strong>has two children</strong>: find successor <span class="math">\(y\)</span> — which must be in <span class="math">\(z\)</span>’s right subtree
<ol type="1">
<li>if <span class="math">\(y\)</span> is <span class="math">\(z\)</span>’s right child then transplant <span class="math">\(z\)</span> by <span class="math">\(y\)</span>, leaving <span class="math">\(y\)</span>’s right child alone</li>
<li>else transplant <span class="math">\(y\)</span> by its own right child, then transplant <span class="math">\(z\)</span> by <span class="math">\(y\)</span></li>
</ol></li>
</ol>
<p>The transplant operation can be handled by simply associating the parent with the new child and vice versa:</p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">replace_node</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">node</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">node</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">==</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">nil</span><span class="p">)</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

  <span class="c1">// ignore this check in red-black trees</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></figure>
<h2 id="two-three-search-trees">2-3 Search Trees</h2>
<p>While <strong>2-3 search tree</strong> can be implemented, they’re mainly used to help understand the implementation of <a href="#red-black-trees">Red-Black Trees</a>, which have better performance.</p>
<p>A <strong>2-3 tree</strong> is either empty or:</p>
<ul>
<li><strong>2-node</strong>: one key and two links
<ul>
<li>left for keys smaller than the left key</li>
<li>right for keys larger than the right key</li>
</ul></li>
<li><strong>3-node</strong>: two keys and three links
<ul>
<li>left for keys smaller than the left key</li>
<li>middle for keys between the node’s keys</li>
<li>right for keys larger than the right key</li>
</ul></li>
</ul>
<h3 id="two-three-tree-searching">Searching</h3>
<p>Searching follows simply from the structure of the tree.</p>
<ol type="1">
<li><strong>search hit</strong> if the key is in the node</li>
<li>if not, recurse into the appropriate link</li>
<li><strong>search miss</strong> if a null link is reached</li>
</ol>
<h3 id="two-three-tree-insertion">Insertion</h3>
<p>Insertion needs to take into consideration the fact that the tree must remain balanced after the operation. The general procedure is that the key is searched for until a node with a null link is reached at the bottom of the tree.</p>
<ul>
<li><strong>single 2-node</strong>
<ol type="1">
<li>replace the 2-node with a 3-node containing the new key</li>
</ol></li>
<li><strong>single 3-node</strong>
<ol type="1">
<li>create two 2-nodes out of each of the two keys</li>
<li>replace the 3-node with a 2-node consisting of the new key</li>
<li>set the 2-node’s links to the two new 2-nodes</li>
</ol></li>
<li><strong>3-node with 2-node parent</strong> — <em>same as above with slight variation</em>
<ol type="1">
<li>create two 2-nodes out of each of the two keys</li>
<li>move the new key into the parent 2-node to make it a 3-node</li>
<li>set the middle link to the 3-node’s left key and right link to the right key</li>
</ol></li>
<li><strong>3-node with 3-node parent</strong>
<ol type="1">
<li>propagate the above operation until the root or a 2-node is encountered</li>
<li>if the root is encountered, split it as in the case of a single 3-node</li>
</ol></li>
</ul>
<p>Perfect balance is preserved because tree height increase occurs at the root, and additions at the bottom of the tree are performed in the form of splitting existing nodes such that the height remains the same.</p>
<p>The <strong>problem</strong> with implementing a direct representation of 2-3 trees is that there are many cases to handle and nodes have to be converted between various types. These operations can incur overhead that nullifies or even makes worse the performance of 2-3 trees compared to regular <abbr title="Binary Search Trees">BST</abbr>s.</p>
<h2 id="red-black-trees">Red-Black Trees</h2>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(2 \lg {n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p><a href="http://en.wikipedia.org/wiki/Red–black_tree">Red-Black trees</a> are trees that guarantee near-perfect balance by maintaining 5 invariants:</p>
<ol type="1">
<li>a node is either <strong>red</strong> or <strong>black</strong></li>
<li>root is <strong>black</strong></li>
<li>all leaves — represented as nil — are <strong>black</strong></li>
<li>both children of every red node are <strong>black</strong></li>
<li>every path from a given node to any of its descendant leaves contains the same number of <strong>black</strong> nodes</li>
</ol>
<p>These properties allow red-black trees to be nearly balanced in even the worst case, allowing them more performance than regular <abbr title="Binary Search Trees">BST</abbr>s. A very neat implementation is <a href="https://github.com/prasanthmadhavan/Red-Black-Tree/blob/master/rbtree.c">available here</a>.</p>
<h3 id="red-black-tree-insertion">Insertion</h3>
<p>The inserted node is attached in the same manner as for <abbr title="Binary Search Trees">BST</abbr>s, except that every node is painted <strong>red</strong> on insertion. However, the inserted node has the possibility of violating any one of the 5 invariants, in which case the situation must be remedied. The following code representing the different cases that must be remedied are split into corresponding individual functions for didactic purposes.</p>
<p>There are three main scenarios that may arise from adding a node:</p>
<ol type="1">
<li>first node added creates a <strong>red</strong> root, violating property <strong>2</strong> (root is <strong>black</strong>)</li>
<li>node is added as child of <strong>black</strong> node, operation completes successfully</li>
<li>consecutive <strong>red</strong> nodes, violating properties <strong>4</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>) and <strong>5</strong> (equal number of <strong>black</strong> nodes per path)</li>
</ol>
<p>Note that scenarios 1 and 3 violate the properties of red-black trees.</p>
<p><strong>First</strong>, the inserted node may be the only node in the tree, making it the root. Since all nodes are inserted as <strong>red</strong>, it should be repainted <strong>black</strong> to satisfy property <strong>2</strong> (root is <strong>black</strong>):</p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case1</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">insert_case2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Second</strong>, if the parent of the inserted node is <strong>black</strong>, the insertion is complete because it is not possible for that to have violated any of the properties:</p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case2</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">insert_case3</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Third</strong>, it is possible that the inserted node creates two consecutive <strong>red</strong> nodes, violating property <strong>3</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>). For this, there are three different scenarios:</p>
<ol type="A">
<li>parent and uncle are both red</li>
<li>direction in which new node and parent lean differ</li>
<li>new node and parent lean in the same direction</li>
</ol>
<p><strong>First</strong>, if the parent and its uncle are <strong>red</strong>, flip their colors and make the grandparent <strong>red</strong> instead. This allows the newly added <strong>red</strong> node to satisfy all properties, since its parent is <strong>black</strong>. However, making the grandparent <strong>red</strong> may possibly violate properties <strong>2</strong> (root is <strong>black</strong>) and <strong>4</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>), so recurse the enforcement algorithm on the grandparent starting from case 1:</p>
<p><img src="/images/notes/algorithms/red-black-trees/insert_1.png" class="center"></p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case3a</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">uncle</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="o">*</span><span class="n">g</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="n">u</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">grandparent</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>

    <span class="n">insert_case1</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">insert_case4</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Second</strong>, the new node could be added diagonal to a <strong>red</strong> parent node, meaning for example the parent node being <strong>red</strong> and the <strong>left child</strong> of its parent and the new node could be <strong>red</strong> (as always) and the <strong>right child</strong> of its parent.</p>
<p>This is ultimately resolved by two rotations, but the first rotation is made to get the new node leaning in the same direction as its parent. This is accomplished by rotating the new node in the direction of the parent’s direction from its parent. In the above example, the new node is its parent’s <strong>right child</strong> and the parent is the grandparent’s <strong>left child</strong>, so the new node is <strong>rotated left</strong>.</p>
<p>There are still consecutive <strong>red</strong> nodes after this rotation, albeit leaning in the same direction. This makes it simple for case 3c to handle, provided it is applied to the ex-parent, i.e. the now-bottom node, since case 3c operates in a more general sense from the perspective of the grandchild.</p>
<p><img src="/images/notes/algorithms/red-black-trees/insert_2.png" class="center"></p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case3b</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">grandparent</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rotate_left</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rotate_right</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">insert_case5</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Third</strong>, the new node could be added below a <strong>red</strong> parent node and leaning in the same direction. For example, the new node is the <strong>left child</strong> of its parent and its parent is the <strong>left child</strong> of its parent (grandparent of the new node) as well.</p>
<p>This is resolved by rotating the grandparent in the direction <strong>opposite</strong> to the direction in which the consecutive <strong>red</strong> links lean. This has the effect of making the parent be the new root of the subtree previously rooted by the grandparent.</p>
<p>The grandparent was known to be <strong>black</strong>, since the <strong>red</strong> parent could not have been a child of it otherwise. Knowing this, the parent — now the root — switches colors with the grandparent, such that the subtree now consists of the <strong>black</strong> root and two <strong>red</strong> children.</p>
<p><img src="/images/notes/algorithms/red-black-trees/insert_3.png" class="center"></p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">insert_case3c</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">grandparent</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="n">g</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="n">rotate_right</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">rotate_left</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<h3 id="red-black-tree-deletion">Deletion</h3>
<p>Deletion is handled similar to deletion in <abbr title="Binary Search Trees">BST</abbr>s, but is a <em>lot</em> more complicated because the tree has to be re-balanced if removing a node from the tree causes it to become unbalanced.</p>
<p>Every resource I looked at — books, sites, university slides, etc. — simply hand-waived the deletion process presumably due to its complexity. The one place that managed to somewhat explain it well was the classic CLRS book, but its implementation consisted of a big, difficult-to-follow while-loop. Instead I decided to go with <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal">wikipedia’s</a> long and dense explanation of its relatively simple implementation which even the <a href="https://github.com/torvalds/linux/blob/master/lib/rbtree.c">Linux kernel uses</a>.</p>
<p><strong>First</strong>, if the node to be deleted has two children then it is replaced by its successor. The successor then has to be deleted, and by definition the successor will have at most one non-leaf child — otherwise it would not be the minimum in that subtree and the left child would have been followed.</p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span>      <span class="p">(</span><span class="o">*</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="n">delete</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span>  <span class="n">key</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="n">delete</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// replace with successor</span>
      <span class="n">node</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">minimum_node</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
      <span class="n">m</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
      <span class="n">delete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
</code></pre></figure>
<p><strong>Second</strong>, if the node to be deleted has a child, simply replace the successor with its child.</p>
<figure class="codeblock"><pre><code class="highlight language-c">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// replace with child, delete child</span>
      <span class="n">delete_one_child</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</code></pre></figure>
<p><strong>Third</strong>, if the node to be deleted has no children, then it is possible to simply delete it.</p>
<figure class="codeblock"><pre><code class="highlight language-c">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// no children, just delete</span>
      <span class="n">free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure>
<h4 id="red-black-tree-deletion-balance">Balance</h4>
<p>If the node is replaced with a successor, that successor is essentially removed from its original location, thereby possibly causing tree unbalanced. For this reason, the original successor node is removed using <code>delete_one_child</code> which re-balances the tree if necessary.</p>
<ul>
<li>node <span class="math">\(M\)</span>: successor to the node to be deleted</li>
<li>node <span class="math">\(C\)</span>: child of <span class="math">\(M\)</span>, prioritized to be a non-leaf child if possible</li>
<li>node <span class="math">\(N\)</span>: child <span class="math">\(C\)</span> in its new position</li>
<li>node <span class="math">\(P\)</span>: <span class="math">\(N\)</span>’s parent</li>
<li>node <span class="math">\(S\)</span>: <span class="math">\(N\)</span>’s sibling</li>
<li>nodes <span class="math">\(S_{L}\)</span> and <span class="math">\(S_{R}\)</span>: <span class="math">\(S\)</span>’s left and right child respectively</li>
</ul>
<p><strong>First</strong>, if <span class="math">\(M\)</span> is <strong>red</strong>, then simply replace it with its child <span class="math">\(C\)</span> which must be <strong>black</strong> by property 4 (both children of <strong>red</strong> nodes are <strong>black</strong>). Any paths that passed through the deleted node will simply pass through one fewer <strong>red</strong> node, maintaining balance:</p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_one_child</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">?</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">:</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

  <span class="n">replace_node</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
</code></pre></figure>
<p><strong>Second</strong>, if <span class="math">\(M\)</span> is <strong>black</strong> and <span class="math">\(C\)</span> is <strong>red</strong>, paint <span class="math">\(C\)</span> <strong>black</strong> and put it in <span class="math">\(M\)</span>’s place. This preserves the same amount of <strong>black</strong> nodes along that path:</p>
<figure class="codeblock"><pre><code class="highlight language-c">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
      <span class="n">child</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
</code></pre></figure>
<p><strong>Third</strong>, the most complex case is when both <span class="math">\(M\)</span> and <span class="math">\(C\)</span> are <strong>black</strong>. Replacing one with the other effectively removes one black node along that path, unbalancing the tree. Begin by replacing <span class="math">\(M\)</span> with its child <span class="math">\(C\)</span>, then proceed to the first re-balancing case:</p>
<figure class="codeblock"><pre><code class="highlight language-c">    <span class="k">else</span>
      <span class="nf">delete_case1</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p>When both <span class="math">\(M\)</span> and <span class="math">\(C\)</span> are <strong>black</strong> nodes, four situations <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> can arise that require re-balancing, unless <span class="math">\(C\)</span>’s new position <span class="math">\(N\)</span> is the new root. If <span class="math">\(C\)</span> becomes the root it simply means that a <strong>black</strong> node was removed from all paths, effectively decreasing the black-height of every path by one and the tree therefore requires no re-balancing.</p>
<p><strong>First</strong>: <span class="math">\(N\)</span>’s sibling <span class="math">\(S\)</span> is <strong>red</strong>. In this case, reverse the colors of <span class="math">\(P\)</span> and <span class="math">\(S\)</span> and rotate <span class="math">\(P\)</span> left. Although all paths still have the same black-height, <span class="math">\(N\)</span>’s sibling <span class="math">\(S\)</span> is now <strong>black</strong> and its parent <span class="math">\(P\)</span> is <strong>red</strong>, allowing fall-through to case 4, 5, or 6:</p>
<p><img src="/images/notes/algorithms/red-black-trees/delete_1.png" class="center"></p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case1</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
      <span class="n">rotate_left</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">rotate_right</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">delete_case2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Second</strong>: <span class="math">\(P\)</span>, <span class="math">\(S\)</span>, and <span class="math">\(S\)</span>’s children are all <strong>black</strong>. Repaint <span class="math">\(S\)</span> <strong>red</strong> so that all paths passing through <span class="math">\(S\)</span> have the same black-height as those that go through <span class="math">\(N\)</span>.</p>
<p><img src="/images/notes/algorithms/red-black-trees/delete_2a.png" class="center"></p>
<p>If <span class="math">\(P\)</span> is <strong>red</strong>, then the tree is violating property <strong>4</strong> (both children of <strong>red</strong> nodes are <strong>black</strong>), fix it by simply painting <span class="math">\(P\)</span> <strong>black</strong>.</p>
<p><img src="/images/notes/algorithms/red-black-trees/delete_2b.png" class="center"></p>
<p>Otherwise, if <span class="math">\(P\)</span> was already <strong>black</strong>, however, then after the painting of <span class="math">\(S\)</span> to <strong>red</strong>, <span class="math">\(P\)</span> now has effectively lost one level from its black-height, so case 1 should be applied to <span class="math">\(P\)</span>:</p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case2</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
      <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span>
    <span class="k">else</span>
      <span class="n">delete_case1</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">delete_case3</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Third</strong>: <span class="math">\(S\)</span> is <strong>black</strong>, <span class="math">\(S_{L}\)</span> is <strong>red</strong>, <span class="math">\(S_{R}\)</span> is <strong>black</strong>, <span class="math">\(N\)</span> is left child of its <span class="math">\(P\)</span>. Rotate <span class="math">\(S\)</span> right, then exchange colors of <span class="math">\(S\)</span> and its new parent. This case just prepares the tree for falling into case 6, since <span class="math">\(N\)</span> now has a <strong>black</strong> sibling — <span class="math">\(S_{L}\)</span> — whose right child is <strong>red</strong>.</p>
<p><img src="/images/notes/algorithms/red-black-trees/delete_3.png" class="center"></p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case3</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
      <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
      <span class="n">rotate_right</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="cm">/* symmetric to above */</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">delete_case4</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></figure>
<p><strong>Fourth</strong>: <span class="math">\(S\)</span> is <strong>black</strong>, <span class="math">\(S_{R}\)</span> is <strong>red</strong>, <span class="math">\(N\)</span> is left child of its <span class="math">\(P\)</span>. Rotate <span class="math">\(P\)</span> left, exchange colors of <span class="math">\(P\)</span> and <span class="math">\(S\)</span>, and make <span class="math">\(S_{R}\)</span> <strong>black</strong>.</p>
<p>This unbalances the tree by increasing black-height of paths through <span class="math">\(N\)</span> by one because either <span class="math">\(P\)</span> became <strong>black</strong> or it was <strong>black</strong> and <span class="math">\(S\)</span> became a <strong>black</strong> grandparent.</p>
<p><img src="/images/notes/algorithms/red-black-trees/delete_4.png" class="center"></p>
<figure class="codeblock"><pre><code class="highlight language-c"><span class="kt">void</span> <span class="nf">delete_case4</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sibling</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

  <span class="n">s</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
  <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="n">rotate_left</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="n">rotate_right</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></figure>
<h2 id="interval-trees">Interval Trees</h2>
<p>Interval trees are useful for efficiently finding all intervals that overlap with any given interval or point.</p>
<p>To construct the tree, the median of the entire range of all of the set of ranges is found. Those ranges in the set that are intersected by the median are stored in the current node. Ranges that fall completely to the left of the median are stored in the left child node, and vice versa with the right node.</p>
<p>At any given node representing the set of ranges intersected by the median at that node, two sorted lists are maintained: one containing all beginning points and the other containing all end points.</p>
<h3 id="intersection-queries">Intersection Queries</h3>
<p>The general operation for queries is to test the set of ranges in a node and then test those in the appropriate child node if the query isn’t equal to the median.</p>
<p>Given a <strong>point</strong> query, the current node is compared with the median. If it’s equal, then every range in that node matches and the search is complete. If the query is less than the median, then the list of beginning points is searched for those beginning points that start before the query point, all of which are matches. Then the search continues into the left child.</p>
<p>Given an <strong>interval query</strong>, the set of beginning and end points are searched to see if they fall within the query interval. These ranges are matches, and they have potential for duplicates if the matched interval begins and ends within the query interval. Finally, to match for ranges which possibly contain the query interval, a point is chosen in the query interval, perhaps the begin or end point, and that point is used as a point query as in the aforementioned point query algorithm.</p>
<h2 id="hash-tables">Hash Tables</h2>
<p>Hash tables consist of an array coupled with a <strong>hash function</strong> — such as <a href="http://en.wikipedia.org/wiki/MurmurHash">MurmurHash</a> or <a href="http://en.wikipedia.org/wiki/CityHash">CityHash</a> — and a <strong>collision resolution</strong> scheme, both of which help map the key to an index within the array.</p>
<h3 id="hash-functions">Hash Functions</h3>
<p>Hash functions need to be consistent, efficient, and should uniformly distribute the set of keys.</p>
<p>A popular and simple hashing function is modular hashing of the form:</p>
<p><span class="math">\[h(k) = k \bmod M\]</span></p>
<p>where <span class="math">\(k\)</span> is the key and <span class="math">\(M\)</span> is the array size, used to avoid integer overflow, usually chosen to be prime. Multiple pieces of data can be combined into one hash by doing:</p>
<p><span class="math">\[(H * R + D) \bmod M\]</span></p>
<p>where <span class="math">\(R\)</span> is a prime number such as a 31, <span class="math">\(H\)</span> is the hash as constructed so far (initially set to some prime number) and <span class="math">\(D\)</span> is the new piece of data.</p>
<p>For example, given a three properties — day, month, and year — the following hash computation could be used:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">day</span>  <span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span> <span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>

<span class="c1">// or</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(((((</span><span class="mi">0</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">day</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">)</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
</code></pre></figure>
<p>Or to hash a given string:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">hash</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">%</span> <span class="n">M</span><span class="o">;</span>
</code></pre></figure>
<p>A simpler hashing scheme that doesn’t account for integer overflow is:</p>
<p><span class="math">\[R * H\]</span></p>
<p>So for example, given a day, month, and year:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="n">day</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">((</span><span class="n">R</span> <span class="o">+</span> <span class="n">day</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">month</span><span class="o">)</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">year</span><span class="o">;</span>
</code></pre></figure>
<h3 id="separate-chaining">Separate Chaining</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(\lg {n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This collision resolution strategy involves storing a linked-list at every entry in the array. The intent is to choose the size of the array large enough so that the linked-lists are sufficiently short.</p>
<p>Separate chaining consists of a two-step process:</p>
<ol type="1">
<li>hash the key to get the index to retrieve the list</li>
<li>sequentially search the list for the key</li>
</ol>
<p>A property of separate chaining is that the average length of the lists is always <span class="math">\(N/M\)</span> in a hash table with <span class="math">\(M\)</span> lists and <span class="math">\(N\)</span> keys.</p>
<h3 id="linear-probing">Linear Probing</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(c \lg {n})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Linear probing is a form of open addressing that relies on empty entries in the array for collision resolution. Linear probing simply consists of:</p>
<ol type="1">
<li>hash the key to get the index</li>
<li>the element at the index determines three outcomes:
<ol type="1">
<li>if it’s an empty position, insert the element</li>
<li>if the position is not empty and the key is equal, replace the value</li>
<li>if the key is not equal, try the next entry and repeat until it can be inserted</li>
</ol></li>
</ol>
<h4 id="hash-table-deletion">Deletion</h4>
<p>The insert and retrieval operations retrieve the index and perform the same operation until the entry is null. This has the consequence that deleting a node cannot <em>simply</em> entail setting the entry to null, or it would prematurely stop the lookup of other keys.</p>
<p>As a result, after setting the entry to null, every key to the right of the removed key also has to be removed — i.e. set to null — and then re-inserted into the hash table using the regular insertion operation.</p>
<h4 id="hash-table-load-factor">Load Factor</h4>
<p>The <strong>load factor</strong> is defined by <span class="math">\(\alpha = N/M\)</span> where <span class="math">\(\alpha\)</span> is the percentage of table entries that are occupied, which can never be 1 since, if the table becomes full, a search miss would go into an infinite loop. Instead, array resizing is performed to ensure that the load factor is between <span class="math">\(\frac {1} {8}\)</span> and <span class="math">\(\frac {1} {2}\)</span>.</p>
<p>The average number of compares, or <em>probes</em>, in a linear-probing hash table of size <span class="math">\(M\)</span> and <span class="math">\(N = \alpha M\)</span> keys is:</p>
<p><span class="math">\[
\text {hits: ~} \frac {1} {2} \left( 1 + \frac {1} {1 - \alpha} \right) \\
\text {misses: ~} \frac {1} {2} \left( 1 + \frac {1} {\left( 1 - \alpha \right)^2} \right)
\]</span></p>
<p>Based on this, when <span class="math">\(\alpha\)</span> is about 0.5 there will be 1.5 compares for a search hit and 2.5 compares for a search miss on average. For this reason, <span class="math">\(\alpha\)</span> should be kept under 0.5 through the use of array resizing.</p>
<h3 id="sparse-vectors">Sparse Vectors</h3>
<p>An application of hash tables can be to implement sparse vectors for the purpose of performing matrix-vector multiplications. In certain situations, the row-vector from a matrix can have a very small amount of non-zero elements. If the matrix was stored in a naive array format it would amount to an immense waste of space and computation.</p>
<p>Instead, sparse vectors are vectors backed by hash tables where the keys correspond to the index of a given element and the value corresponds to that element’s value. This solution is used in Google’s PageRank algorithm.</p>
<h1 id="graphs">Graphs</h1>
<p>A <strong>graph</strong> is a set of <strong>vertices</strong> and a collection of <strong>edges</strong> that each connect a pair of vertices. This definition allows for <strong>self-loops</strong> (edges that connect a vertex to itself) and <strong>parallel edges</strong> (multiple edges connecting the same vertex pair).</p>
<p>Graphs with parallel edges are sometimes known as <strong>multigraphs</strong>, whereas graphs with no parallel edges or self-loops are <strong>simple graphs</strong>.</p>
<p>Two vertices connected by an edge are <strong>adjacent</strong>, and the edge is <strong>incident</strong> to both vertices. A vertex’ <strong>degree</strong> is the number of edges connected to it. A <strong>subgraph</strong> is a sub-set of edges and associated vertices that still constitutes a graph.</p>
<p>Paths in graphs are sequences of vertices connected by edges. <strong>Simple paths</strong> have no repeated vertices. A path forms a <strong>cycle</strong> if it has at least one edge whose first and last vertices are the same, and a <strong>simple cycle</strong> if the cycle consists of no repeated edges or vertices. The number of edges in a path determines its <strong>length</strong>.</p>
<p>A graph is <strong>connected</strong> if a path exists from every vertex to every other vertex. A graph that isn’t connected consists of <strong>connected components</strong> which are connected subgraphs of the graph.</p>
<p><strong>Acyclic graphs</strong> are graphs with no cycles. A tree is an acyclic connected graph, and a disjoint set of trees is a <strong>forest</strong>.</p>
<p>A graph <span class="math">\(G\)</span> with <span class="math">\(V\)</span> vertices is a tree if any of the following are satisfied:</p>
<ul>
<li><span class="math">\(G\)</span> has <span class="math">\(V - 1\)</span> edges and no cycles</li>
<li><span class="math">\(G\)</span> has <span class="math">\(V - 1\)</span> edges and is connected</li>
<li><span class="math">\(G\)</span> is connected but removing a single edge disconnects it</li>
<li><span class="math">\(G\)</span> is acyclic but adding any edge creates a cycle</li>
<li>exactly one simple path connects each pair of vertices in <span class="math">\(G\)</span></li>
</ul>
<p>A <strong>spanning tree</strong> of a connected graph is a subgraph that contains all of the vertices as a single tree. A <strong>spanning forest</strong> of a graph is the union of all spanning trees of its connected components.</p>
<p>A graph’s <strong>density</strong> is its proportion of possible paris of vertices that are connected. A <strong>sparse</strong> graph has relatively few of the possible edges present, compared to a <strong>dense</strong> one.</p>
<p>A <strong>bipartite graph</strong> is one whose vertices can be divided into two sets such that all edges connect a vertex in one set with a vertex in the other.</p>
<p><strong>Answers</strong>:</p>
<ul>
<li>is there a way to connect one item to another by following the connections?</li>
<li>how many other items are connected to a given item?</li>
<li>what is the shortest chain of connections between two items?</li>
</ul>
<h2 id="undirected-graphs">Undirected Graphs</h2>
<p>An <strong>undirected graph</strong> is one in which the connections don’t have an associated direction. There are various data structures that can be used represent graphs:</p>
<ul>
<li><strong>adjacency matrix</strong>: a <span class="math">\(V \times V\)</span> boolean array where row <span class="math">\(v\)</span> and column <span class="math">\(w\)</span> are set to true if vertices <span class="math">\(v\)</span> and <span class="math">\(w\)</span> are connected with an edge.</li>
<li><strong>array of adjacency lists</strong>: a vertex-indexed array of lists of the vertices adjacent to each vertex, similar to hash tables with separate chaining</li>
<li><strong>array of edges</strong>: a collection of Edge objects each containing two instance variables for each of the connected vertices</li>
</ul>
<p>Adjacency lists have the best balance between space and time performance. They have space usage proportional to <span class="math">\(V + E\)</span>, constant time to add an edge, and time proportional to the degree of <span class="math">\(v\)</span> to iterate through adjacent vertices.</p>
<h3 id="depth-first-search">Depth-First Search</h3>
<p>Depth-First Search (<abbr title="Depth-First Search">DFS</abbr>) is a graph traversal algorithm that visits a vertex, marks that vertex as visited, then visits all unmarked adjacent vertices.</p>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">count</span><span class="o">++</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// v connects to w, i.e. v-w</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre><figcaption><span>depth-first search</span></figcaption></figure>
<p>To trace the paths in the graph, an array can be kept of size <span class="math">\(V\)</span> indexed by a given vertex whose value is the vertex that connects to it. This array of edges represents a tree rooted at the source vertex.</p>
<h3 id="breadth-first-search">Breadth-First Search</h3>
<p>Breadth-First Search (<abbr title="Breadth-First Search">BFS</abbr>) traversal aids in finding the shortest path between two vertices. Its basic operation consists of:</p>
<ol type="1">
<li>enqueue the source vertex</li>
<li>dequeue the current vertex</li>
<li>mark and enqueue all adjacent vertices</li>
<li>repeat 2-3 until the queue is empty</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vertexQueue</span><span class="p">;</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">vertexQueue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">vertexQueue</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vertexQueue</span><span class="p">.</span><span class="n">dequeue</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">vertexQueue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre><figcaption><span>breadth-first search</span></figcaption></figure>
<h3 id="connected-components">Connected Components</h3>
<p>Depth-First Search can also be used to find connected components of a graph. This is accomplished by initiating <abbr title="Depth-First Search">DFS</abbr> on every unmarked vertex and each time it is called on a vertex, set the vertex’ connected component identifier.</p>
<p>A run of <abbr title="Depth-First Search">DFS</abbr> finds, and thus marks, every vertex in a connected component. Upon completing such a run, a counter variable signifying the connected componenet identifier is incremented and then it is called on the next unmarked vertex in the graph, i.e. a vertex not in a connected component found so far.</p>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">findConnectedComponents</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">());</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">marked</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">();</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// set connected component identifier</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre><figcaption><span>finding connected components</span></figcaption></figure>
<p>Compared to <a href="#dynamic-connectivity">Union-Find</a>, the <abbr title="Depth-First Search">DFS</abbr> approach is theoretically faster because it provides a constant-time guarantee. However, in practice the difference is negligible and Union-Find tends to be faster because it doesn’t have to build a full representation of a graph. Perhaps more importantly, the <abbr title="Depth-First Search">DFS</abbr> approach has to preprocess the graph by running <abbr title="Depth-First Search">DFS</abbr> on the separate connected components. As a result, Union-Find is an online algorithm where it can be queried even while new edges are added without having to re-preprocess the graph.</p>
<h3 id="cycle-detection">Cycle Detection</h3>
<p><abbr title="Depth-First Search">DFS</abbr> can also be used to determine if there are cycles present in a graph. This is accomplished by keeping track of the vertex previous to the one being focused on by the <abbr title="Depth-First Search">DFS</abbr>. If one of the current vertex’ neighbors is already marked and it is not the previous vertex, then it means that there is an edge to an already marked vertex, thus forming a cycle.</p>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">bool</span> <span class="nf">detectCycles</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">();</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="n">u</span><span class="p">)</span>
      <span class="n">hasCycle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre><figcaption><span>cycle detection</span></figcaption></figure>
<h3 id="bipartite-detection">Bipartite Detection</h3>
<p><abbr title="Depth-First Search">DFS</abbr> can also be used to determine whether or not the graph is bipartite. Another way to frame the question is: can the vertices of the graph be assigned one of two colors such that no edge connects vertices of the game color?</p>
<p>This is accomplished by maintaining a vertex-indexed array that will store that vertex’ color. As <abbr title="Depth-First Search">DFS</abbr> traverses the graph, it will alternate the color of every vertex it visits. The graph starts out as assumed to be bipartite, and only if <abbr title="Depth-First Search">DFS</abbr> encounters a marked vertex whose color is the same as the current vertex does it conclude that the graph is not bipartite.</p>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">bool</span> <span class="nf">bipartiteDetect</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">.</span><span class="n">V</span><span class="p">();</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">color</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">isBipartite</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre><figcaption><span>bipartite detection</span></figcaption></figure>
<h2 id="directed-graphs">Directed Graphs</h2>
<p>The edges in <strong>directed graphs</strong> have an associated one-way direction, such that edges are defined by an ordered pair of vertices that define a one-way adjacency. A directed graph (or <strong>digraph</strong>) is a set of vertices and a collection of directed edges, each connecting an ordered pair of vertices. The <strong>outdegree</strong> of a vertex is the number of edges pointing from it, while the <strong>indegree</strong> is the number of edges pointing to it.</p>
<p>The first vertex in a directed edge is the <strong>head</strong> and the second vertex is the <strong>tail</strong>. Edges are drawn as arrows pointing from head to tail, such as <span class="math">\(v \rightarrow w\)</span>.</p>
<p>Directed graphs can be represented by adjacency lists with the stricter property that if node <span class="math">\(w\)</span> is present in the adjacency list corresponding to <span class="math">\(v\)</span>, it simply means that there is a directed edge <span class="math">\(v \rightarrow w\)</span>, but not vice versa unless explicitly defined.</p>
<h3 id="digraph-reachability">Reachability</h3>
<p>The same exact implementation of reachability testing by <abbr title="Depth-First Search">DFS</abbr> used in undirected graphs can be used for digraphs, and can be expanded to allow for reachability testing from multiple sources which has applications in regular expression matchers or mark-and-sweep garbage collection strategies, for example.</p>
<p>Mark-and-sweep garbage collection (<abbr title="Garbage Collector">GC</abbr>) strategies typically reserve one bit per object for the purpose of garbage collection. The <abbr title="Garbage Collector">GC</abbr> then periodically <strong>marks</strong> a set of potentially accessible objects by running digraph reachability tests on the graph of object references, then it <strong>sweeps</strong> through all of the unmarked objects, collecting them for reuse for new objects.</p>
<h3 id="directed-cycle-detection">Cycle Detection</h3>
<p>A digraph with no directed cycles is known as a directed acyclic graph (<abbr title="Directed Acyclic Graph">DAG</abbr>). For this reason, checking a digraph for directed cycles answers the question of whether the digraph is <abbr title="Directed Acyclic Graph">DAG</abbr>.</p>
<p>Directed cycle detection is accomplished by maintaining a boolean array representing whether or not a directed path belongs to the same connected component. Then during <abbr title="Depth-First Search">DFS</abbr> if the encountered vertex is already marked and is part of the same component, it returns the path from the current vertex through the cycle back to the current vertex. If no such cycle exists, the graph is a <abbr title="Directed Acyclic Graph">DAG</abbr>.</p>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">onStack</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hasCycle</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">edgeTo</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">onStack</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">cycle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">cycle</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

      <span class="n">cycle</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
      <span class="n">cycle</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">onStack</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre><figcaption><span>directed cycle detection</span></figcaption></figure>
<h3 id="topological-order">Topological Order</h3>
<p>Topological sort puts the vertices of a digraph in order such that all of its directed edges point from a vertex earlier in the order to a vertex later in the order. Three different orders are possible, which are accomplished by saving each vertex covered by the <abbr title="Depth-First Search">DFS</abbr> in a queue or stack, depending on the desired order:</p>
<ul>
<li><strong>preorder</strong>: put the vertex on a queue before the recursive calls</li>
<li><strong>postorder</strong>: put the vertex on a queue after the recursive calls</li>
<li><strong>reverse postorder</strong>, aka <em>topological order</em>: put the vertex on a stack after the recursive calls</li>
</ul>
<p>This ability of <abbr title="Depth-First Search">DFS</abbr> follows from the fact that <abbr title="Depth-First Search">DFS</abbr> covers each vertex exactly once when run on digraphs.</p>
<h3 id="strong-connectivity">Strong Connectivity</h3>
<p>Two vertices <span class="math">\(v\)</span> and <span class="math">\(w\)</span> are <strong>strongly connected</strong> if they are mutually reachable, i.e. <span class="math">\(v \leftrightarrow w\)</span>. Consequently, an entire digraph is <strong>strongly connected</strong> if <em>all</em> of its vertices are strongly connected to one another. Further, <strong>strong components</strong> are connected components of a graph that are strongly connected.</p>
<p>The <a href="http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm">Kosaraju-Sharir</a> algorithm is able to find strongly connected components in digraphs. The algorithm operates as follows:</p>
<ol type="1">
<li>given digraph <span class="math">\(G\)</span> and its reverse digraph <span class="math">\(G^R\)</span>, compute the reverse postorder of <span class="math">\(G^R\)</span></li>
<li>run standard <abbr title="Depth-First Search">DFS</abbr> on <span class="math">\(G\)</span> on the vertices in the order generated by step 1</li>
<li>all vertices visited on a recursive <abbr title="Depth-First Search">DFS</abbr> call from the constructor are a strong component, so identify them</li>
</ol>
<p>The algorithm can answer the following questions:</p>
<ul>
<li>are two given vertices strongly connected?</li>
<li>how many strong components does the digraph contain?</li>
</ul>
<figure class="codeblock"><pre><code class="highlight language-cpp"><span class="kt">void</span> <span class="nf">findStrongComponents</span><span class="p">(</span><span class="k">const</span> <span class="n">Digraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Digraph</span> <span class="n">reverse</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">:</span> <span class="n">reverse</span><span class="p">.</span><span class="n">reversePost</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">Digraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="p">.</span><span class="n">adj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marked</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
<span class="p">}</span>
</code></pre><figcaption><span>kosaraju-sharir algorithm</span></figcaption></figure>
<p>The algorithm can be understood by considering a kernel <abbr title="Directed Acyclic Graph">DAG</abbr>, or <em>condensation digraph</em>, associated with each digraph, formed by collapsing all vertices in each strong component to a single vertex. This <abbr title="Directed Acyclic Graph">DAG</abbr> can then be put into reverse topological order. Remember that reverse postorder of a <abbr title="Directed Acyclic Graph">DAG</abbr> is equivalent to topological sort.</p>
<p>The algorithm begins by finding a vertex that is in a sink component of the kernel <abbr title="Directed Acyclic Graph">DAG</abbr>. A <strong>sink component</strong> is one that has no edges pointing from it. Running <abbr title="Depth-First Search">DFS</abbr> from this vertex only visits the vertices in that component. <abbr title="Depth-First Search">DFS</abbr> then marks the vertices in that component, effectively removing them from further consideration in that digraph. It then repeats this by finding another sink component in the resulting kernel <abbr title="Directed Acyclic Graph">DAG</abbr>.</p>
<p>The first vertex in a reverse postorder of <span class="math">\(G\)</span> is in a <em>source</em> component of the kernel <abbr title="Directed Acyclic Graph">DAG</abbr>, whereas the first vertex in a reverse postorder of the <em>reverse</em> digraph <span class="math">\(G^R\)</span> is in a <em>sink</em> component of the kernel <abbr title="Directed Acyclic Graph">DAG</abbr>.</p>
<h3 id="all-pairs-reachability">All-Pairs Reachability</h3>
<p>All-Pairs reachability asks: given a digraph, is there a directed path from a given vertex <span class="math">\(v\)</span> to another given vertex <span class="math">\(w\)</span>? This can be answered by creating a separate graph representation known as a transitive closure, which allows for straightforward checking of which vertex is reachable by others.</p>
<p><img src="/images/notes/algorithms/graphs/transitive-closure.png" class="right"></p>
<p>The <strong>transitive closure</strong> of digraph <span class="math">\(G\)</span> is another digraph with the same set of vertices but with an edge from <span class="math">\(v\)</span> to <span class="math">\(w\)</span> in the transitive closure if and only if <span class="math">\(w\)</span> is reachable from <span class="math">\(v\)</span> in <span class="math">\(G\)</span>. Transitive closures are generally represented as a matrix of booleans where row <span class="math">\(v\)</span> at column <span class="math">\(w\)</span> is true if <span class="math">\(w\)</span> is reachable from <span class="math">\(v\)</span> in the digraph.</p>
<p>Finding the transitive closure of a digraph can be accomplished by running <abbr title="Depth-First Search">DFS</abbr> on every vertex of the digraph and storing the resulting reachability array for each each vertex from which <abbr title="Depth-First Search">DFS</abbr> was run. However, it can be impractical for large graphs because it uses space proportional to <span class="math">\(V^2\)</span> and time proportional to <span class="math">\(V(V + E)\)</span>.</p>
<h2 id="minimum-spanning-trees">Minimum Spanning Trees</h2>
<p>An <strong>edge-weighted graph</strong> is a graph where the edges have associated weights or costs. Edge-weighted graphs can be represented with adjacency lists containing edge objects which contain the two vertices, one of which is the index of the adjacency list, as well as the weight for that edge.</p>
<p>A <strong>spanning tree</strong> is a connected subgraph with no cycles that includes all of the vertices in the graph. A <strong>minimum spanning tree</strong> (<abbr title="Minimum Spanning Tree">MST</abbr>) is a spanning tree whose weight — the sum of all of its edges’ weights — is no larger than the weight of any other spanning tree for that graph.</p>
<p>Adding an edge to a tree creates a cycle and removing an edge from a tree breaks it into two separate subtrees. Knowing this, a <strong>cut</strong> of a graph is a partition of its vertices into two nonempty disjoint sets, connected by a <strong>crossing edge</strong>.</p>
<h3 id="prims-algorithm">Prim’s Algorithm</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(E \lg {E})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(E)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>This method of finding the <abbr title="Minimum Spanning Tree">MST</abbr> operates by attaching a new edge to a growing tree at each step. Starting with any vertex from the graph to create a single-vertex tree, each time taking the minimum-weight edge that connects a vertex on the tree to a vertex not yet on the tree.</p>
<p>The vertices in the tree being built are represented using a vertex-indexed boolean array where an element is set to true if the vertex is in the tree. The edges in the tree can be represented with a queue that collects edges or a vertex-indexed array of edge objects. Crossing edges are held in a minimum priority queue, making the operation of choosing the edge with the lowest weight particularly straightforward.</p>
<p>The act of adding an edge to the tree corresponds to adding a vertex to the tree. When this occurs, all edges from the newly added vertex to all vertices not in the tree must be added to the crossing edges priority queue. Furthermore, any edges previously in the priority queue that connected the newly added vertex to a vertex already in the tree become <em>ineligible</em> — or they would create a cycle — and should be ignored or removed.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">prim</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">// start at arbitrary vertex</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span> <span class="c1">// fetch lowest weight edge from frontier</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// skip ineligible edges</span>

    <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="c1">// add edge to result</span>

    <span class="c1">// visit either v or w</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">)])</span> <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>prim's algorithm</span></figcaption></figure>
<h4 id="eager-prims">Eager Prim’s Algorithm</h4>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(E \lg {E})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(V)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The above implementation is lazy with respect to ignoring ineligible edges in the priority queue. That approach leaves ineligible edges in the priority queue until they’re dequeued for consideration and discarded if they are ineligible.</p>
<p>By contrast, an <strong>eager approach</strong> would make sure those edges aren’t present in the priority queue from the beginning. The eager version of Prim’s algorithm uses two vertex-index arrays:</p>
<ul>
<li>an array for the shortest edges to vertices which are reachable from the tree within one edge</li>
<li>an array for the weight of the shortest edge stored in the aforementioned array</li>
</ul>
<p>For each vertex present in the above arrays, the vertex index associated with its weight are stored in a minimum priority queue, such that when the minimum weight is removed the associated index is returned. The implication of maintaining the priority queue this way is that given the next minimum-weight crossing edge returned by the priority queue, its associated vertex is the next one to add to the <abbr title="Minimum Spanning Tree">MST</abbr>.</p>
<p>An improvement from the lazy implementation is that the eager implementation uses space proportional to <span class="math">\(V\)</span> whereas the lazy implementation uses <span class="math">\(E\)</span>.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">primEager</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">distTo</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
  <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>
    <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">());</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// v-w is ineligible</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">changeKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
      <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>eager prim's algorithm</span></figcaption></figure>
<h3 id="kruskals-algorithm">Kruskal’s Algorithm</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(E \lg {E})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(E)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>An alternative method for finding the <abbr title="Minimum Spanning Tree">MST</abbr> is to process the edges in increasing order of their weight values, each time taking an edge for the <abbr title="Minimum Spanning Tree">MST</abbr> that doesn’t form a cycle, stopping once <span class="math">\(V-1\)</span> edges have been aggregated. The edges form a forest of trees, gradually growing into a single tree (the <abbr title="Minimum Spanning Tree">MST</abbr>). The algorithm can be thought of as starting with a forest of <span class="math">\(V\)</span> single-vertex trees, and on each step finding an edge to connect two trees until there is only one left (the <abbr title="Minimum Spanning Tree">MST</abbr>).</p>
<p>The implementation uses a priority queue of edges based on their weight, a union-find data structure to identify potential cycles, and a queue to collect edges for for the <abbr title="Minimum Spanning Tree">MST</abbr>.</p>
<p>Despite the simplicity of Kruskal’s algorithm, it is generally slower than Prim’s because it has to check if an edge is already connected using the union-find data structure on each edge that is considered for the <abbr title="Minimum Spanning Tree">MST</abbr>.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">kruskal</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
  <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
  <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UF</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">mst</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span> <span class="c1">// fetch edge with lowest weight</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// check if already connected</span>
    <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span> <span class="c1">// if not, merge them in the union-find data structure</span>
    <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="c1">// add the edge to result</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>kruskal's algorithm</span></figcaption></figure>
<h2 id="shortest-paths">Shortest Paths</h2>
<p>The <strong>shortest path</strong> from vertex <span class="math">\(s\)</span> to <span class="math">\(t\)</span> in an edge-weighted digraph is a directed path from <span class="math">\(s\)</span> to <span class="math">\(t\)</span> such that no other such path has a lower weight. A <strong>shortest-path tree</strong> (<abbr title="Shortest-Paths Tree">SPT</abbr>) for a source vertex <span class="math">\(s\)</span> is a subgraph containing <span class="math">\(s\)</span> and all the vertices reachable from <span class="math">\(s\)</span> that forms a directed tree rooted at <span class="math">\(s\)</span> such that every path is a shortest path in the digraph.</p>
<p><strong>Edge relaxation</strong> refers to replacing an existing edge that reaches <span class="math">\(w\)</span> with a new edge <span class="math">\(v \rightarrow w\)</span> if the new edge makes the path from the source vertex to <span class="math">\(w\)</span> be of lower cost than it was previously.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
    <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>edge relaxation</span></figcaption></figure>
<p><strong>Vertex relaxation</strong> is similar to edge relaxation except that it relaxes all of the edges pointing from a given vertex.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>vertex relaxation</span></figcaption></figure>
<h3 id="dijkstras-algorithm">Dijkstra’s Algorithm</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(E \lg {V})\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(V)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Dijkstra’s alrogithm is similar to Prim’s algorithm for finding the <abbr title="Minimum Spanning Tree">MST</abbr>. Dijkstra’s algorithm finds the <abbr title="Shortest-Paths Tree">SPT</abbr> by finding the lowest-weight non-tree vertex as provided by an index minimum-priority queue and relaxing that vertex.</p>
<p>Dijkstra’s algorithm <strong>requires</strong> that edges be non-negative.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
  <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>

  <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">);</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">pg</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>
    <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">());</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">changeKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
      <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>dijkstra's algorithm</span></figcaption></figure>
<p>To specifically find the shortest path from the source vertex to an arbitrary vertex, simply terminate the search as soon as the target vertex comes off of the priority queue.</p>
<h3 id="topological-sort">Topological Sort</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(E + V)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(V)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Shortest paths can be found much more efficiently in acyclic graphs, specifically, the single-source problem can be solved in linear time, negative edge weights are easily handled, and other related problems such as finding the longest paths are solvable. This is possible by relaxing vertices in topological order.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">shortestPathAcyclic</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> 
    <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
  <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">topologicalOrder</span><span class="o">())</span>
    <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>shortest-paths in DAG</span></figcaption></figure>
<p>This approach can be used for finding the longest path between two vertices in a <abbr title="Directed Acyclic Graph">DAG</abbr>, accomplished by creating a copy of the <abbr title="Directed Acyclic Graph">DAG</abbr> and negating the weight of every edge.</p>
<h3 id="parallel-job-scheduling">Parallel Job Scheduling</h3>
<p>The <strong>critical path method</strong> for parallel job scheduling consists of encoding the constraints of the scheduling problem in a <abbr title="Directed Acyclic Graph">DAG</abbr>. Both a source vertex <span class="math">\(s\)</span> and a sink vertex <span class="math">\(t\)</span> are created on either ends of the graph. Jobs are encoded in the graph as a pair of nodes connected by an edge whose weight corresponds to that job’s duration. For each precedence constraint <span class="math">\(v \rightarrow w\)</span>, add a zero-weight edge from <span class="math">\(v\)</span> to <span class="math">\(w\)</span>. Finally, add a zero-weight edge from the source to every job’s start vertex and from every job’s end vertex to the sink.</p>
<p>When the scheduling problem is encoded in this manner, it can be solved by scheduling each job at the time corresponding to its longest path from the source vertex.</p>
<p>Relative deadlines can be encoded as a negative weighted edge going from the constrained job (vertex) to the job (vertex) which the deadline is relative to. However, relative deadlines can quickly make solutions infeasible with the aforementioned algorithms (Dijkstra’s and Acyclic Shortest Paths).</p>
<h3 id="bellman-ford-algorithm">Bellman-Ford Algorithm</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(VE)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Average</td>
<td style="text-align: left;"><span class="math">\(O(E + V)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(V)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>The problem of finding the shortest paths can be generalized to graphs containing negative cycles. The Bellman-Ford algorithm accomplishes this by adding the source vertex to a queue and entering a loop where a vertex is dequeued and relaxed, and any vertex affected by that relaxation gets enqueued.</p>
<p>A <strong>negative cycle</strong> is a directed cycle with net negative weight. No shortest path between <span class="math">\(s\)</span> and <span class="math">\(v\)</span> can consist of a vertex that lies within a negative cycle, or the weight of the path can be made arbitrarily low and a <em>shortest</em> path would “never” be achieved.</p>
<p>To prevent the Bellman-Ford algorithm from looping infinitely due to negative cycles, it has to ensure to terminate after <span class="math">\(V\)</span> passes either by keeping track with a counter or by detecting negative cycles within a subgraph.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">bellmanFord</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
  <span class="n">onQ</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">hasNegativeCycle</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
    <span class="n">onQ</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
      <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>

      <span class="k">if</span> <span class="o">(!</span><span class="n">onQ</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="n">onQ</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">cost</span><span class="o">++</span> <span class="o">%</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">findNegativeCycle</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>bellman-ford algorithm</span></figcaption></figure>
<p>If the queue is not empty after <span class="math">\(V\)</span> passes through each edge then there is a negative cycle. By extension, if a negative cycle is present in a graph, the Bellman-Ford algorithm can end up in an infinite loop, continuously lowering the weight of each affected path.</p>
<p>This is mitigated by checking for negative cycles on every <span class="math">\(V^{th}\)</span> call to relax, as on line 26 of the above code listing. On every such interval, a <a href="#directed-cycle-detection">cycle finder</a> is initiated on the sub-graph denoted by the edges so-far considered by Bellman-Ford.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">findNegativeCycle</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="n">EdgeWeightedDigraph</span> <span class="n">spt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedDigraph</span><span class="o">(</span><span class="n">V</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">spt</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>

  <span class="n">EdgeWeightedCycleFinder</span> <span class="n">cf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedCycleFinder</span><span class="o">(</span><span class="n">spt</span><span class="o">);</span>

  <span class="n">cycle</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="na">cycle</span><span class="o">();</span>
<span class="o">}</span>
</code></pre><figcaption><span>negative cycle finder</span></figcaption></figure>
<h1 id="strings">Strings</h1>
<p>Strings have special properties which necessitate more efficient algorithms for sorting and searching. Other subjects concerning strings include tries, regular expressions, and data compression.</p>
<h2 id="string-sorting">Sorting</h2>
<p>Certain properties of strings and alphabets can make for more efficient sorting algorithms for strings.</p>
<h3 id="counting-sort">Counting Sort</h3>
<p>Counting sort, also known as key-indexed counting, essentially involves computing a histogram of the number of occurrences of each character, then regenerating the array in sorted order using that information.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

<span class="kt">int</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

<span class="c1">// count occurrences</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>

<span class="c1">// compute key ranges</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
  <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

<span class="c1">// populate sorted array</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">key</span><span class="o">()]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

<span class="c1">// copy back to original array</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</code></pre><figcaption><span>counting sort</span></figcaption></figure>
<h3 id="least-significant-digit-sort">Least Significant Digit Sort</h3>
<div class="right">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(NW)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(N)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Least Significant Digit (<abbr title="Least Significant Digit">LSD</abbr>) sort works by sorting the strings based on the last character and then repeating this operation up until the first character. This is accomplished by modifying the counting sort algorithm so that it does a pass for every character in the string. This is mainly useful if all strings are the same length <span class="math">\(W\)</span> and relatively small alphabet size <span class="math">\(R\)</span>.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">W</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>

  <span class="n">String</span><span class="o">[]</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">d</span><span class="o">--)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

    <span class="c1">// count occurrences</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++;</span>

    <span class="c1">// compute key ranges</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
      <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

    <span class="c1">// populate sorted array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">)]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

    <span class="c1">// copy back to original array</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
      <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>least significant digit sort</span></figcaption></figure>
<h3 id="most-significant-digit-sort">Most Significant Digit Sort</h3>
<div class="right">
<table>
<caption><span class="math">\(w:\)</span> average string length</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Best</td>
<td style="text-align: left;"><span class="math">\(\Omega (N)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(Nw)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(N + WR)\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Most Significant Digit (<abbr title="Most Significant Digit">MSD</abbr>) sort is similar to <abbr title="Least Significant Digit">LSD</abbr> except that it operates in left-to-right order instead, meaning it works fine for variable-length strings. This is accomplished by performing counting sort to sort the array of strings based on their first character, then recursively performing the same operation on the sub-array of strings with the same first letter.</p>
<p>Because <abbr title="Most Significant Digit">MSD</abbr> works left-to-right and strings may be of variable — not uniform — length, the possibility of reaching the end of the string requires special handling. This is solved by observing the fact that a smaller string <span class="math">\(S_1\)</span> that is a prefix of larger string <span class="math">\(S_2\)</span> should naturally come before it in lexicographically sorted order. For example, <em>sea</em> should come before <em>seashore</em>.</p>
<p>This order is maintained by keeping a separate count of such strings that have had all of their characters sorted. This count is held at <code>count[1]</code>. A string has had all of its characters sorted if the character position currently being sorted is past the length of the string currently being considered. Once the counts are converted to key ranges, such strings will naturally be inserted at the beginning of the sorted sub-array.</p>
<p>On each recursion of the sorting operation, an array for counts is allocated whose size is proportional to the alphabet size, occurrences are counted, transformed to key ranges, and so on. The point is that these operations can come to dominate the sorting operation, which makes having a cutoff for small sub-arrays crucial. After the cutoff, insertion sort takes over, with the slight modification that it only operates on the <span class="math">\(d^{th}\)</span> character position onward.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">charAt</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="n">aux</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// cut off point for just running insertion sort</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Insertion</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">2</span><span class="o">];</span>

  <span class="c1">// count occurrences</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">]++;</span>

  <span class="c1">// compute key ranges</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
    <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>

  <span class="c1">// populate sorted array</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">aux</span><span class="o">[</span><span class="n">count</span><span class="o">[</span><span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

  <span class="c1">// copy back to original array</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">aux</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">lo</span><span class="o">];</span>

  <span class="c1">// recurse for each remaining character value</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span><span class="o">],</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>most significant digit sort</span></figcaption></figure>
<h3 id="three-way-string-quicksort">Three-way String QuickSort</h3>
<div class="right">
<table>
<caption><span class="math">\(w:\)</span> average string length</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Case</th>
<th style="text-align: left;">Growth</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Best</td>
<td style="text-align: left;"><span class="math">\(\Omega (N)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Worst</td>
<td style="text-align: left;"><span class="math">\(O(Nw \lg {R})\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Space</td>
<td style="text-align: left;"><span class="math">\(O(W + \lg {N})\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>Three-way quicksort can be adapted to work on a per-character basis similar to <abbr title="Most Significant Digit">MSD</abbr>. The advantages of this are that the algorithm doesn’t use extra space — unlike <abbr title="Most Significant Digit">MSD</abbr> — and that the number of sub-arrays per recurse is bounded at three.</p>
<p>A direct result of only splitting into three sub-arrays is that more data movements are required to get elements into their correct position compared to <abbr title="Most Significant Digit">MSD</abbr>. However, three-way quicksort’s three-way splits adapt well to handling equal keys, keys with small arrays, and keys that fall into a small range.</p>
<p>Research has shown that no algorithm can beat 3-way string quicksort by more than a constant factor.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">stringQuickSort</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">lt</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">gt</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">gt</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">charAt</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">d</span><span class="o">);</span>

    <span class="k">if</span>      <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">++,</span> <span class="n">i</span><span class="o">++);</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">gt</span><span class="o">--);</span>
    <span class="k">else</span>            <span class="n">i</span><span class="o">++;</span>
  <span class="o">}</span>

  <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">,</span> <span class="n">gt</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">gt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>string quicksort</span></figcaption></figure>
<h2 id="tries">Tries</h2>
<p>Trie structures exploit string properties to provide much faster string search, with hits taking time proportional to the length of the key and where misses require examining only a few characters.</p>
<p><img src="/images/notes/algorithms/tries/trie.png" class="right"></p>
<p>The structure of tries is comprised of a tree where every node has <span class="math">\(R\)</span> <strong>links</strong> where <span class="math">\(R\)</span> is the size of the alphabet. Every node also has an associated <strong>label</strong> corresponding to the character value consumed to reach the node. The root node has no such label as there is no link pointing to it. Every node also also has an associated <strong>value</strong> corresponding to the value associated with the key denoted by the path ending at the particular node.</p>
<p>A <strong>search hit</strong> occurs when the trie search arrives at the final node and that node’s value is not empty. A <strong>search hit</strong> occurs both if the final node’s value is empty or if the search terminated on a null link.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="n">Value</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">Node</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>trie search</span></figcaption></figure>
<p>Trie insertion simply consists of searching for the key and setting the value. If the key does not already exist, then create nodes for every character not yet in the trie.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span> <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="o">}</span>

<span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>trie insertion</span></figcaption></figure>
<p>Tries also allow operations for collecting keys with a common prefix. This is accomplished by finding the node at the end of the prefix’ path and then recursively performing <abbr title="Breadth-First Search">BFS</abbr> on every node and enqueueing any node that has a non-empty value.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
  <span class="n">collect</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>trie key collection</span></figcaption></figure>
<p>This can also be modified to allow wildcard pattern matches, for example, keys that match <code>fin.</code> could include <code>fine</code>, <code>find</code>, etc.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">keysWithPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
  <span class="n">collect</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>

  <span class="kt">char</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">||</span> <span class="n">next</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span>
      <span class="n">collect</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">c</span><span class="o">,</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>trie key wildcards</span></figcaption></figure>
<h3 id="trie-deletion">Deletion</h3>
<p>Deletion is a straightforward process in tries, simply involving finding the node and emptying its value. If this operation makes the node’s parent’s children all be null, then the same operation must be run on the parent.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="o">}</span>

<span class="n">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
    <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>
    <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
      <span class="k">return</span> <span class="n">x</span><span class="o">;</span>

  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>trie deletion</span></figcaption></figure>
<h3 id="ternary-search-trees">Ternary Search Trees</h3>
<p>Ternary Search Trees (<abbr title="Ternary Search Trees">TST</abbr>s) seek to avoid the excessive space cost of regular R-way tries demonstrated above. <abbr title="Ternary Search Trees">TST</abbr>s are structured such that each node has only three links for characters less than, equal to, and greater than the node.</p>
<p>R-way tries can provide the fastest search, finishing the operation with a constant number of compares. However, space usage increases rapidly with larger alphabets <abbr title="Ternary Search Trees">TST</abbr>s are preferable, sacrificing a constant number of compares for a logarithmic number of compares.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="n">Node</span> <span class="nf">get</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>

  <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">key</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>ternary search tree search</span></figcaption></figure>
<p>Insertion is similar to insertion with tries except that only one of three links can be taken, instead of <span class="math">\(R\)</span> links.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span> <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="o">}</span>

<span class="n">Node</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">x</span><span class="o">,</span> <span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">d</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="o">}</span>

  <span class="k">if</span>      <span class="o">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span>  <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">c</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">key</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">mid</span>   <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">mid</span><span class="o">,</span>   <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>ternary search tree insertion</span></figcaption></figure>
<h2 id="substring-search">Substring Search</h2>
<p>Searching for a string within another string is a very common operation that can also benefit from exploiting certain properties of strings.</p>
<h3 id="brute-force-substring-search">Brute-Force</h3>
<p>The most straightforward approach is a brute-force algorithm where every character in the text is checked to see if the pattern’s first character matches, and if so, checks to see if the second character in the pattern matches, and so on.</p>
<p>If any character in the pattern matches during this check, the pattern iterator is not incremented and instead the text iterator is set back the amount of spaces equal to the pattern iterator, which essentially moves the text iterator one position past the position where the match checking was initiated. The pattern iterator is then reset to zero.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
      <span class="n">j</span><span class="o">++;</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="n">j</span><span class="o">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span>
  <span class="k">else</span>        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>brute-force substring search</span></figcaption></figure>
<h3 id="knuth-morris-pratt">Knuth-Morris-Pratt</h3>
<p>The Knuth-Morris-Pratt (<abbr title="Knuth-Morris-Pratt">KMP</abbr>) substring search algorithm considers that it’s probably not necessary to backtrack all the way to the beginning, since the characters along that stretch of the sequence have already been seen. One way to know the correct distance to backtrack is accomplished using a Deterministic Finite-State Automaton (<abbr title="Deterministic Finite-State Automaton">DFA</abbr>). There are other methods that either <a href="http://algs4.cs.princeton.edu/53substring/KMPplus.java.html">build an <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr></a> or build a <a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm">partial-match table</a>.</p>
<h4 id="kmp-dfa-composition">DFA Composition</h4>
<p>The <abbr title="Deterministic Finite-State Automaton">DFA</abbr> is constructed such that every state corresponds to the characters in the patterns, storing their position in the pattern. At each state there exists a transition to the next state corresponding with the character consumed in the pattern. At each state there are also transitions going back to previous states, corresponding to backtracking on a pattern mismatch. Finally, the end state corresponds to the halt state and as such has no transitions leaving it.</p>
<p>The <abbr title="Deterministic Finite-State Automaton">DFA</abbr> is essentially represented by a table <code>dfa[c][j]</code> such that <code>c</code> corresponds to the character in the text currently being considered and <code>j</code> corresponds to the position of the character currently being considered in the pattern, i.e. the state in the <abbr title="Deterministic Finite-State Automaton">DFA</abbr>. In effect, <code>dfa[c][j]</code> determines which state to proceed to when at state <code>j</code> considering character <code>c</code>.</p>
<p>The value stored at <code>dfa[c][j]</code> therefore is the identifier of the state that the algorithm should jump to — this could mean either backtracking in the case of a mismatch when <span class="math">\(C \neq pattern[J]\)</span> or a progression to the next state when <span class="math">\(C = pattern[J]\)</span>.</p>
<h4 id="kmp-prevent-backtracking">Preventing Backtracking</h4>
<p>In a normal brute-force algorithm when a pattern matching a segment of the text starting at <code>t[i]</code> mismatches at position <code>j</code>, the entire pattern is re-checked starting on the character to the right: <code>t[i + 1]</code>, effectively having to re-check characters <code>t[i + 1]</code> to <code>t[i + j - 1]</code>.</p>
<p>For example, the following mismatches at position 4:</p>
<figure class="codeblock"><pre><code class="highlight language-text">0 1 2 3 4 5
A B C D E F
A B C D F</code></pre></figure>
<p>So in a brute-force algorithm the pattern would have to be shifted to the right by one position:</p>
<figure class="codeblock"><pre><code class="highlight language-text">0 1 2 3 4 5
A B C D E F
  A B C D F</code></pre></figure>
<p>However, this essentially means that the text segment from position 1 to 3 has to be rechecked, which we would prefer to avoid. The important observation to make is that the text had <strong>already matched</strong> the pattern <em>up to</em> (but not including) position <code>j</code> where the mismatch occurred. That is, the text segment <code>t[i .. i + j - 1]</code> is equal to <code>p[0 .. j - 1]</code> where <code>p</code> is the pattern. Since we would have to shift to the right one character, this means that the text that would have to be rechecked corresponds to <code>p[1 .. j - 1]</code>. Feeding this to the <abbr title="Deterministic Finite-State Automaton">DFA</abbr> takes us to the state where we can appropriately handle <code>t[i + j]</code>.</p>
<p><strong>Based on this observation</strong>, we can conclude that at every state we can add transitions for mismatch cases based on the transitions that would be made for the equivalent mismatch that would occur at the state we would arrive at if we had fed the input <code>p[0 .. j - 1]</code> to the <abbr title="Deterministic Finite-State Automaton">DFA</abbr>. For this reason, a “pointer” to this state is kept at every iteration of the <abbr title="Deterministic Finite-State Automaton">DFA</abbr> construction, where each iteration is comprised of defining all transitions for a given state.</p>
<h4 id="kmp-dfa-construction">DFA Construction</h4>
<p>Given the important observation above, the construction of the <abbr title="Deterministic Finite-State Automaton">DFA</abbr> is very straightforward. A pointer to a fall-back state <code>X</code> is maintained to appropriately establish transitions in the event of a mismatch.</p>
<ol type="1">
<li>the first transition is established: <code>dfa[p[0]][0] = 1</code></li>
<li>for each character in the pattern, a state is created
<ol type="1">
<li>for every character in the alphabet, a transition is established based on the transition that would be taken at state <code>X</code>, since these are the mismatch transitions</li>
<li>a match transition is created for the current pattern character</li>
<li>the pointer to the fall-back state is updated to the state arrived at by following the transition corresponding to the current pattern character from the previous fall-back state</li>
</ol></li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">constructDFA</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">dfa</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">dfa</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
      <span class="n">dfa</span><span class="o">[</span><span class="n">c</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">[</span><span class="n">c</span><span class="o">][</span><span class="n">X</span><span class="o">];</span>

    <span class="n">dfa</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)][</span><span class="n">X</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>DFA construction</span></figcaption></figure>
<h4 id="kmp-search">KMP Search</h4>
<p>Now that the <abbr title="Deterministic Finite-State Automaton">DFA</abbr> is constructed, a string can be searched easily. It simply iterates the text pointer on each iteration, while the pattern’s pointer iterates based on the output from the <abbr title="Deterministic Finite-State Automaton">DFA</abbr> given the current text character as input. Iteration ends when the full length of either the text or the pattern is exhausted. If the full pattern was consumed then there was a match and the pointer to the start of the match is returned.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)][</span><span class="n">j</span><span class="o">];</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span>
  <span class="k">else</span>        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>KMP search</span></figcaption></figure>
<h3 id="boyer-moore">Boyer-Moore</h3>
<p>The Boyer-Moore substring search algorithm works by reading the pattern for comparison in reverse order while skipping through the text accordingly to facilitate this. When a comparison mismatches, the algorithm looks in a skip table to determine how far ahead to jump forward to begin the next match attempt. This behavior is known as the mismatched character heuristic.</p>
<h4 id="bm-skip-table">Skip Table</h4>
<p>The mismatched character heuristic makes use of the aforementioned skip table. The table is indexed by a character from the alphabet and gives the index of its rightmost occurrence in the pattern, or -1 if not present. That very value defines how far ahead to skip if that character from the text caused the mismatch.</p>
<p>The table is constructed by first setting all entries to -1, then for every character in the pattern, set that character’s entry to its position in the pattern.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">constructSkipTable</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">R</span><span class="o">];</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="n">right</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
    <span class="n">right</span><span class="o">[</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>skip table construction</span></figcaption></figure>
<h4 id="bm-search">Search</h4>
<p>The searching algorithm, as previously stated, iterates the text pointer <code>i</code> from left-to-right and the pattern pointer <code>j</code> right-to-left. If there is a mismatch with character <code>c</code> in the text, then one of three things can occur:</p>
<ol type="1">
<li><strong>if <code>c</code> is not in the pattern</strong>: increment <code>i</code> by <code>j + 1</code> to effectively skip that segment of the text that will not match</li>
<li><strong>if <code>c</code> is in the pattern</strong>: use the <code>right</code> array to line up the pattern with the text such that the right-most occurrence of <code>c</code> in the pattern is lined up with <code>c</code> in the text</li>
<li><strong>if <code>i</code> is not increased due to the above case</strong>: then just increment <code>i</code> instead so that the pattern always slides at least one position to the right</li>
</ol>
<p>The above cases are handled with the simple statement <code>skip = j - right[text.charAt(i + j)]</code>. Case 1 is handled because characters not present in the pattern are stored as -1 in the table, thereby turning the statement into <code>skip = j + 1</code>. Case 2 is handled normally by finding the right-most occurrence’ position of <code>c</code> in the table and subtracting that from <code>j</code>. Case 3 is handled by simply checking if <code>skip</code> is less than one and if so setting it to one. If <code>skip</code> was never changed from its initial value of zero, then a match was found.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">skip</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">skip</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">!=</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">right</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)];</span> <span class="c1">// determine skip distance</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">skip</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// ensure text traversal</span>
        <span class="k">break</span><span class="o">;</span> <span class="c1">// mismatch; stop trying to match the rest</span>
      <span class="o">}</span>
  
    <span class="c1">// no skip distance set, therefore text matched</span>
    <span class="c1">// i is position where the match began</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">skip</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>boyer-moore search</span></figcaption></figure>
<h3 id="rabin-karp">Rabin-Karp</h3>
<p>The Rabin-Karp algorithm conceptually works by computing a hash of the pattern and then hashing every equal-lengthed substring in the text to find a match. The key idea is that a string of length <span class="math">\(M\)</span> corresponds to an <span class="math">\(M\)</span>-digit base-<span class="math">\(R\)</span> number. So a proper hash function would convert an <span class="math">\(M\)</span>-digit base-<span class="math">\(R\)</span> number to an integer value between <span class="math">\(0\)</span> and <span class="math">\(Q - 1\)</span> where <span class="math">\(Q\)</span> is some very large prime number. This is possible with a simple modular hashing scheme, by taking the remainder of dividing the number by <span class="math">\(Q\)</span>.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">long</span> <span class="nf">hash</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">key</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>modular hash function via horner's method</span></figcaption></figure>
<p>The problem with using the above approach for the text is that it incurs the cost of multiplication, addition, and remainder calculations for <em>each character</em>. Instead, for an <span class="math">\(M\)</span>-character substring of the text where <span class="math">\(t_i\)</span> corresponds to <code>text.charAt(i)</code> the hash <span class="math">\(x_i\)</span> can be computed as:</p>
<p><span class="math">\[ x_i = t_i R^{M - 1} + t_{i + 1} R^{M - 2} + \ldots + t_{i + M - 1} R^0 \]</span></p>
<p>From the above formula it’s apparent that the hash is constructed by individual <em>hash components</em> derived from each character in the text. It stands to reason, then, that the hash of the text shifted one character to the right is:</p>
<p><span class="math">\[ x_{i + 1} = \left( x_i - t_i R^{M - 1} \right) R + t_{i + M} \]</span></p>
<p>That is, the original hash minus the hash component of the first character of the previous text, plus the hash component of the new ending character.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">pattern</span><span class="o">,</span> <span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">M</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">longRandomPrime</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">RM</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="o">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">RM</span><span class="o">)</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span> <span class="c1">// compute R^(M - 1) % Q</span>
  <span class="kt">long</span> <span class="n">patHash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">pattern</span><span class="o">,</span> <span class="n">M</span><span class="o">);</span>

  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">txtHash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">txt</span><span class="o">,</span> <span class="n">M</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">patHash</span> <span class="o">==</span> <span class="n">txtHash</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// match</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">txtHash</span> <span class="o">=</span> <span class="o">(</span><span class="n">txtHash</span> <span class="o">+</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">RM</span> <span class="o">*</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">M</span><span class="o">)</span> <span class="o">%</span> <span class="n">Q</span><span class="o">)</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span>
    <span class="n">txtHash</span> <span class="o">=</span> <span class="o">(</span><span class="n">txtHash</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">%</span> <span class="n">Q</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">patHash</span> <span class="o">==</span> <span class="n">txtHash</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
       <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// match</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// return true for Monte Carlo</span>
<span class="c1">// or check pattern vs text[i .. i - M + 1] for Las Vegas</span>
<span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="o">}</span>
</code></pre><figcaption><span>rabin-karp</span></figcaption></figure>
<h2 id="regular-expressions">Regular Expressions</h2>
<p>A Regular Expression pattern can be represented as a Non-Deterministic Finite-State Automaton (<abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr>) where every character in the pattern corresponds to a state in the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr>, followed by an accept state. Characters from the alphabet have an outgoing edge (match transition) going to the next state (character) in the pattern. Metacharacters such as parentheses, pipes, and asterisks have at least one outgoing edge (<span class="math">\(\epsilon\)</span>-transition) going to another state that represents their purpose.</p>
<p><abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> traversal in this context occurs as follows:</p>
<ul>
<li><strong>match transitions</strong>: if current state corresponds to a character in the alphabet and the current character in the text matches it, the automaton can transition from it, i.e. consume the character</li>
<li><strong><span class="math">\(\epsilon\)</span>-transitions</strong>: if no match is made in the pattern, any transition can be taken from a metacharacter, so called for effectively matching the empty string <span class="math">\(\epsilon\)</span></li>
</ul>
<p>The traversal of the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> is handled in the following manner:</p>
<ol type="1">
<li><strong>at the start state</strong>: find all set of states reachable via <span class="math">\(\epsilon\)</span> transitions</li>
<li>consume pattern character if there’s a match in one of the possible states</li>
<li><strong>from each match state</strong>:
<ol type="1">
<li>add set of states reachable via match transitions</li>
<li>add set of states reachable via <span class="math">\(\epsilon\)</span> transitions</li>
</ol></li>
<li>repeat at 2</li>
</ol>
<p>As the text input is fed to the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr>, on input character the following conditions can arise:</p>
<ul>
<li><strong>set of states contains accept state</strong>: the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> therefore <em>accepts</em> the text, i.e. there was a match</li>
<li><strong>set of states doesn’t contain the accept state</strong>: feed it the next character</li>
<li><strong>the end of the text has been reached</strong>: there was no match</li>
</ul>
<p>The <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> is simply represented by the pattern string and a digraph representing the <span class="math">\(\epsilon\)</span>-transitions.</p>
<h3 id="regex-match-checking">Match Checking</h3>
<p>From this information, it is possible to create an algorithm that determines whether a regular expression matches the provided text. Reachability is determined by a Directed <abbr title="Depth-First Search">DFS</abbr> implementation <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. This is straightforward because the <abbr title="Depth-First Search">DFS</abbr> would only operate on the digraph, which only represents <span class="math">\(\epsilon\)</span>-transitions.</p>
<p>First, the set of states reachable via <span class="math">\(\epsilon\)</span>-transitions from the start state are collected:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">boolean</span> <span class="nf">match</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
  <span class="n">DirectedDFS</span> <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedDFS</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">.</span><span class="na">marked</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="n">pc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">matches</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
</code></pre></figure>
<p>As the text is fed into the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> one character at a time, the set of reachable states is checked for a match with the current character. For each match, its next state is added to the collection of matches representing the set of states reachable from the current state(s).</p>
<figure class="codeblock"><pre><code class="highlight language-java">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">pc</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">re</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">text</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="o">)</span>
        <span class="n">matches</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</code></pre></figure>
<p>Each of the states reachable via <span class="math">\(\epsilon\)</span>-transitions from each of the states collected are added to the collection:</p>
<figure class="codeblock"><pre><code class="highlight language-java">    <span class="n">pc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedDFS</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">matches</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">dfs</span><span class="o">.</span><span class="na">marked</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        <span class="n">pc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></figure>
<p>Once the entire text has been consumed, the final iteration of the above loop would leave the final set of reachable states intact. If this set contains the final, <em>accept</em> state, then the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> accepts the text — that is, there was indeed a match. Otherwise, there wasn’t a match.</p>
<figure class="codeblock"><pre><code class="highlight language-java">  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">pc</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">M</span><span class="o">)</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>regular expression matching</span></figcaption></figure>
<h3 id="regex-nfa-construction">NFA Construction</h3>
<p>The construction of the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr> is accomplished similar to how Djikstra’s <a href="http://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a> works for evaluating mathematical expressions in infix notation by using two stacks: one for operators and another for values.</p>
<p>In this context, a stack is maintained for the operators and a digraph the size of the length of the pattern plus one (to account for the accept state) is maintained to represent the <abbr title="Non-Deterministic Finite-State Automaton">NFA</abbr>’s <span class="math">\(\epsilon\)</span>-transitions. <strong>Concatenation</strong> is already handled implicitly by nature of how the pattern is stored.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="n">Digraph</span> <span class="nf">NFA</span><span class="o">(</span><span class="n">String</span> <span class="n">regex</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ops</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
  <span class="n">re</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="n">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Digraph</span><span class="o">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// +1 for accept state</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</code></pre></figure>
<p>For <strong>parentheses</strong> and <strong>or expressions</strong>, the position of the <code>(</code> or <code>|</code> is pushed.</p>
<figure class="codeblock"><pre><code class="highlight language-java">    <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;|&#39;</span><span class="o">)</span>
      <span class="n">ops</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</code></pre></figure>
<p>If a <code>)</code> is encountered and it signified the end of an <strong>or expression</strong>, then the appropriate edges must be created. A regex <code>(A | B)</code> is handled by adding two <span class="math">\(\epsilon\)</span>-transitions: one from the <code>(</code> to the <code>B</code> and the other from the <code>|</code> to the <code>)</code>. Push the position of the <code>|</code> (having previously pushed the <code>(</code>).</p>
<figure class="codeblock"><pre><code class="highlight language-java">    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">or</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">or</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;|&#39;</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">lp</span><span class="o">,</span> <span class="n">or</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">or</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">else</span> <span class="n">lp</span> <span class="o">=</span> <span class="n">or</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></figure>
<p><strong>Closures</strong> are detected by looking ahead of the current state (if possible). If one is found, then an edge is created to the <code>*</code> and another is created from the <code>*</code> to the current state.</p>
<figure class="codeblock"><pre><code class="highlight language-java">    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">lp</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
      <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">lp</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></figure>
<p>Finally, <code>)</code>, <code>*</code>, and <code>)</code> each also have an <span class="math">\(\epsilon\)</span>-transition leading to the next state in the pattern.</p>
<figure class="codeblock"><pre><code class="highlight language-java">    <span class="k">if</span> <span class="o">(</span><span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;*&#39;</span> <span class="o">||</span> <span class="n">re</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="o">)</span>
      <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">G</span><span class="o">;</span>
<span class="o">}</span>
</code></pre><figcaption><span>NFA construction</span></figcaption></figure>
<h2 id="data-compression">Data Compression</h2>
<p>Universally good lossless data compression is impossible because, for example, it would mean that data could be compressed over and over again until eventually reaching a compressed length of 0. Instead, lossless compression aims to exploit the known structure of the target data for the best compression ratio.</p>
<h3 id="run-length-encoding">Run-Length Encoding</h3>
<p>Run-Length Encoding (<abbr title="Run-Length Encoding">RLE</abbr>) is a classic method of encryption that replaces repeat occurrences of characters with their repeat count. For example, the following consists of 15 zeros, 7 ones, 7 zeros, and 11 ones:</p>
<figure class="codeblock"><pre><code class="highlight language-text">0000000000000001111111000000011111111111</code></pre></figure>
<p>With <abbr title="Run-Length Encoding">RLE</abbr>, given a count size of 4 bits, it can be replaced with 15 (<code>1111</code>), 7 (<code>0111</code>), 7, and 11 (<code>1011</code>):</p>
<figure class="codeblock"><pre><code class="highlight language-text">1111011101111011</code></pre></figure>
<p>In general, each count is encoded in one byte. If a run of repeated characters is greater than the maximum size representable by the count size (i.e. 255), the first 255 is encoded, then a zero-lengthed run of the alternate character, then again the next chunk of the original long repeated character.</p>
<h3 id="huffman-compression">Huffman Compression</h3>
<p>Huffman Compression exploits the frequency of individual characters. For example, in <code>ABRACADABRA!</code>, the most frequently occurring character <code>A</code> could be represented by <code>0</code>, <code>B</code> by <code>1</code>, <code>R</code> with <code>00</code>, <code>C</code> with <code>01</code>, <code>D</code> with <code>10</code>, and <code>!</code> with <code>11</code>, resulting in <code>01000010100100011</code>.</p>
<p>The problem with the above representation is that the interpretation of the above encoded data is ambiguous because the characters aren’t delimited and some of the characters’ codes are prefixes of others. For example, <code>A</code> is <code>0</code>, <code>B</code> is <code>1</code>, and <code>C</code> is <code>01</code>, so when <code>01</code> is read, it isn’t clear if it is meant to be interpreted as <code>AB</code> or <code>C</code>.</p>
<p>Instead, a property known as <strong>prefix-free code</strong> is enforced for the encodings, which prevents any code from being a prefix of another. In the above, a possible representation could be <code>A</code> with <code>0</code>, <code>B</code> with <code>1111</code>, <code>C</code> with <code>110</code>, <code>D</code> with <code>100</code>, <code>R</code> with <code>1110</code>, and <code>!</code> with <code>101</code>, yielding the encoding <code>011111110011001000111111100101</code>. While this is a slightly longer representation, it is unambiguous.</p>
<p>Prefix-free codes can be easily represented using a trie where left links are <code>0</code> and right links are <code>1</code>. Leave nodes contain the character represented by the bits of the edges of the path used to reach them. Each node in the trie has an associated frequency (used during construction) and character (for leaves).</p>
<p>Constructing the trie consists of first creating a forest of 1-node trees — all of which are leaves — one for each character in the input, with its frequency variable set to the number of times it appears in the input. The trie is then constructed from the bottom-up by merging the two least frequent characters (nodes) with a new parent node with its frequency set to their sum. This is greatly facilitated by a priority queue:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="n">Node</span> <span class="nf">buildTrie</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">freq</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">freq</span><span class="o">[</span><span class="n">c</span><span class="o">],</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>

    <span class="n">Node</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="sc">&#39;\0&#39;</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">freq</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="na">freq</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="k">return</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
<span class="o">}</span>
</code></pre><figcaption><span>trie construction</span></figcaption></figure>
<p>The way in which the trie is constructed ensures that the more frequent characters (nodes) are closer to the root, and as a result are encoded with fewer bits.</p>
<p>One thing to recognize is that the trie has to somehow be encoded in the compressed data so that it can then be decompressed. The trie can be encoded in a bitstream by performing pre-order traversal (root - left - right), and at each node:</p>
<ul>
<li>if the node is a leaf, output a <code>1</code> and then the binary representation of the character</li>
<li>otherwise, write a <code>0</code> then recurse on the left node then the right (i.e. pre-order)</li>
</ul>
<p>Reading the trie into an actual trie structure is just as straightforward, where the type of node to create is determined by the leading bit.</p>
<p><strong>Decompression</strong> consists of simply traversing the trie as each bit is read. If a leaf is encountered, output the character and restart traversal from the root.</p>
<p><strong>Compression</strong> requires the existence of a code table mapping each character to the appropriate code. This table is derived from the trie by traversing the trie, keeping track of the bitstring along its path, and when a leaf node is encountered, the bitstring is associated with that character in the code table. Compression then simply requires looking up each character from the data in the code table and outputting the appropriate code.</p>
<h3 id="lzw-compression">LZW Compression</h3>
<p>LZW <strong>compression</strong> works by having variable-length code words for fixed-length input patterns. Code words are kept in a trie as with Huffman compression. A code counter is maintained and incremented after each new code is added to the trie. The initial trie is constructed from the alphabet, one node being created from each character with its code stored within. The rest of the trie is constructed as the input is read:</p>
<ol type="1">
<li>the longest prefix of the input present in the trie is found and its value output to the compressed stream</li>
<li>if the length of the prefix is shorter than the remaining input length, a new code is added for the string consisting of the prefix concatenated with the next character in the input stream. This is a simple operation, essentially done by adding a new node with the new code to the node at which the prefix ends</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">compress</span><span class="o">(</span><span class="n">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">TST</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TST</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">st</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>

  <span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">longestPrefixOf</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">),</span> <span class="n">W</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">)</span>
      <span class="n">st</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="o">),</span> <span class="n">code</span><span class="o">++);</span>

    <span class="n">input</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">R</span><span class="o">,</span> <span class="n">W</span><span class="o">);</span>
  <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre><figcaption><span>LZW compression</span></figcaption></figure>
<p><strong>Decompression</strong> depends on a table indexed by codes and valued by strings (prefixes), this is constructed from the alphabet. The code of the first character in the input stream is read and its associated string is retrieved from the table. Decompression continues until the EOF character is encountered, on each iteration doing the following:</p>
<ol type="1">
<li>the string associated with the code is output</li>
<li>another code is read, break if EOF</li>
<li>the string associated with the code is retrieved</li>
<li>if the current code counter is equal to the next (lookahead) code — therefore making it impossible to read what the next code’s first character is, since it’s in the process of being constructed — then first character of the string currently being constructed is appended to its end, following basic logic</li>
<li>a new code is added to the table at an incremented code corresponding to the previously read string concatenated with the first character of the current string’s first character</li>
</ol>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">decompress</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">String</span><span class="o">[]</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">L</span><span class="o">];</span>
  <span class="kt">int</span> <span class="n">codeword</span> <span class="o">=</span> <span class="n">BinaryStdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">(</span><span class="n">W</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="o">+</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">;</span>

  <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="s">&quot; &quot;</span><span class="o">;</span>

  <span class="n">String</span> <span class="n">val</span> <span class="o">=</span> <span class="n">st</span><span class="o">[</span><span class="n">codeword</span><span class="o">];</span>

  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
    <span class="n">codeword</span> <span class="o">=</span> <span class="n">BinaryStdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">(</span><span class="n">W</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">codeword</span> <span class="o">==</span> <span class="n">R</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>

    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">st</span><span class="o">[</span><span class="n">codeword</span><span class="o">];</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">codeword</span><span class="o">)</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">)</span>
      <span class="n">st</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">BinaryStdOut</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre><figcaption><span>LZW decompression</span></figcaption></figure>
<h1 id="context">Context</h1>
<p>Miscellaneous algorithms follow.</p>
<h2 id="b-trees">B-Trees</h2>
<p>A B-Trees of order <span class="math">\(M\)</span> is a tree consisting of internal and external <span class="math">\(k\)</span>-nodes each consisting of <span class="math">\(k\)</span> keys where <span class="math">\(2 \leq k \leq M - 1\)</span> at the root and <span class="math">\(M/2 \leq k \leq M - 1\)</span> at every other node. <strong>Internal nodes</strong> contain copies of keys, where every key is greater than or equal to its parent node’s associated key, but not greater than the parent node’s next largest key. <strong>External nodes</strong> are the leaves of the tree that associate keys with data. A <strong>sentinel key</strong> is created to be less than all other keys and is the first key in the root node.</p>
<h3 id="b-tree-insertion">Insertion</h3>
<p>To insert a key, the tree is recursively descended by following the link pertaining to the interval upon which the inserted key falls until an external node is reached. The tree is balanced on the way up the tree after the recursive call. If a node is full it is split into two <span class="math">\(M/2\)</span>-nodes and attached to a parent 2-node (if at the root) or a <span class="math">\((k + 1)\)</span>-node where <span class="math">\(k\)</span> was the original size of the full node’s parent. Whenever a node is split, the smallest key in the new node (or both smallest keys from both nodes if at the root) is inserted into the parent node.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">add</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">Page</span> <span class="n">left</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="n">Page</span> <span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">split</span><span class="o">();</span>

    <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Page</span><span class="o">();</span>
    <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">left</span><span class="o">);</span>
    <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">right</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Page</span> <span class="n">h</span><span class="o">,</span> <span class="n">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">isExternal</span><span class="o">())</span> <span class="o">{</span> <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span> <span class="k">return</span><span class="o">;</span> <span class="o">}</span>

  <span class="n">Page</span> <span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="n">add</span><span class="o">(</span><span class="n">next</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span>
    <span class="n">h</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">next</span><span class="o">.</span><span class="na">split</span><span class="o">());</span>

  <span class="n">next</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre><figcaption><span>B-Tree insertion</span></figcaption></figure>
<h2 id="suffix-arrays">Suffix Arrays</h2>
<p>Suffix arrays are arrays of suffixes of a given text which help with procedures such as finding the longest repeated substring in some text.</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kd">class</span> <span class="nc">SuffixArray</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">suffixes</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">SuffixArray</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="n">suffixes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="n">Array</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">suffixes</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lcp</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lcp</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">lcp</span><span class="o">(</span><span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]);</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* binary search */</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">select</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">index</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">N</span> <span class="o">-</span> <span class="n">suffixes</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre><figcaption><span>suffix array</span></figcaption></figure>
<p>Using this suffix array class, the longest repeated substring can be found efficiently:</p>
<figure class="codeblock"><pre><code class="highlight language-java"><span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readAll</span><span class="o">();</span>
  <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
  <span class="n">SuffixArray</span> <span class="n">sa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SuffixArray</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
  <span class="n">String</span> <span class="n">lrs</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>

  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="na">lcp</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">lrs</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
      <span class="n">lrs</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="n">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lrs</span><span class="o">);</span>
<span class="o">}</span>
</code></pre><figcaption><span>longest repeated substring</span></figcaption></figure>
<h2 id="network-flow">Network-Flow</h2>
<p>The Network-Flow problem concerns itself with finding the settings in a network that maximize the flow from source to sink. At each junction in the network there are switches that control the flow’s distribution between it’s outgoing edges. The problem can be modeled as an edge-weighted digraph with a single source and sink pair, where the weights correspond to the capacity of the edge.</p>
<p>An <strong>st-flow</strong> is a set of edge flows for the network that represent the distribution of flow values for each edge. An <strong>st-flow value</strong> is the sink’s inflow. The network-flow problem can be described as finding an st-flow such that no other st-flow has a larger st-flow value. Such an st-flow can be referred to as a <strong>maxflow</strong>.</p>
<h3 id="ford-fulkerson">Ford-Fulkerson</h3>
<p>The Ford-Fulkerson algorithm, also known as the <em>augmenting-path algorithm</em>, works by increasing flows incrementally along paths from the source to the sink. It works by considering that each edge consists of a <em>forward edge</em> and a <em>backward edge</em>.</p>
<p>A path is found in the network in which there are no full forward edges and no empty backward edges. The flow of the network can then be increased by an amount <span class="math">\(X\)</span>, by increasing flow in forward edges by <span class="math">\(X\)</span> and decreasing flow in backward edges by <span class="math">\(X\)</span> in this path. The value of <span class="math">\(X\)</span> is the minimum of the unused capacities in forward edges and backward edges in the path. This path that can be used to increase flow in the network is known as an <strong>augmenting path</strong>.</p>
<p>Following from this, the maxflow can be found by starting with zero flow everywhere and gradually increase the flow along any augmenting path from source to sink until there are no more augmenting paths.</p>
<p>A <strong>residual network</strong> has the same vertices as the original. For every edge in the original network: if its flow is positive, an edge should be created in the residual with an opposite direction and capacity equal to the flow. Also, if its flow is less than its capacity, an edge should be added in the same direction as the original edge with capacity equal to the difference between its capacity and flow.</p>
<p>This means that if — in the original — an edge’s flow is zero then there’ll only be one edge (in the same direction) and if instead the flow is full there’ll only be one edge (in the opposite direction).</p>
<p>The residual network is useful because any path in it from source to sink corresponds directly to an augmenting path in the original network. As an augmenting path’s flow is incremented, when an edge in the path becomes full or empty, it corresponds to changing direction or disappearing in the residual network.</p>
<p>The <strong>shortest-augmenting-path</strong> method finds the maxflow by finding an augmenting path using <abbr title="Breadth-First Search">BFS</abbr> and incrementing it.</p>
<h2 id="np-complete-problems">NP-Complete Problems</h2>
<ul>
<li><strong>clique problem</strong>: find complete subgraphs, or <em>cliques</em>, in a graph</li>
<li><strong>vertex cover</strong>: find a set of vertices in a graph such that each edge in the graph is incident to at least one vertex in the set</li>
<li><strong>travelling salesman problem</strong>: find the shortest possible path cycle that visits every vertex in a graph</li>
<li><strong>graph coloring</strong>: color every vertex–edge in a graph such that no two adjacent vertices–edges have the same color</li>
<li><strong>knapsack</strong>: given a set of items with different values and a container of a maximum capacity, find the combination of items that fits in the container and has the largest total value.</li>
</ul>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://courses.csail.mit.edu/6.851/spring12/">MIT CSAIL 6.861: Advanced Data Structures</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://www.cs.umd.edu/class/spring2008/cmsc420/">University of Maryland, CMSC 420</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="http://wwwisg.cs.uni-magdeburg.de/ag/lehre/WS1011/GDS/">Universität Magdeburg, Geometric Datastructures</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Skiena p. 109, § 4.3<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>The <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal">Wikipedia implementation’s</a> 6 cases were condensed to 4 as was done in the Linux kernel <a href="https://github.com/torvalds/linux/blob/master/lib/rbtree.c">Red-Black tree implementation</a>. Cases 1 and 2 were merged since case 1 is simply a check to see if the node is the root. Cases 3 and 4 were merged because they handle the same scenario, with case 4 simply being a handler for a special case of 3.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Sedgewick p. 570, algorithm 4.4<a href="#fnref6">↩</a></p></li>
</ol>
</section></div>
  <div class="meta">
    <div class="date"><i class="fa fa-calendar fa-fw"></i> July 15, 2013</div>
    <div class="notes"><i class="fa fa-pencil fa-fw"></i> <a href="..">Notes</a></div>
    <div class="commit"><i class="fa fa-code-fork fa-fw"></i> <a href='https://github.com/blaenk/blaenk.github.io/commits/source/provider/notes/algorithms.markdown'>History</a><span class='hash'>, <a href='https://github.com/blaenk/blaenk.github.io/commit/3c69d8c' title='typo'>3c69d8c</a></span></div>
  </div>
</article>


  </div>
  <footer id="footer" class="inner">
    <span id="social">
      <a href="https://github.com/blaenk" title="github"><i class="fa fa-github-alt"></i></a>
      &middot;
      <a href="http://stackoverflow.com/users/101090/jorge-israel-pena" title="stackoverflow"><i class="fa fa-stack-overflow"></i></a>
      &middot;
      <a href="https://twitter.com/blaenk" title="twitter"><i class="fa fa-twitter"></i></a>
      &middot;
      <a href="mailto:jorge.israel.p@gmail.com" title="email"><i class="fa fa-envelope"></i></a>
      &middot;
      <a href="/atom.xml" title="feed"><i class="fa fa-rss-square"></i></a>
    </span>
  </footer>
  
  
  <!-- google analytics -->
  <script async="true" type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37339861-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <!--MathJax CDN-->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      messageStyle: "none"
    });

    MathJax.Hub.Register.MessageHook('End Process', function() {
      jQuery('#MathJax_Font_Test').empty();
      jQuery('.MathJax_Display').parent('.math').addClass('mobile-math');
    });
  </script>
  <script async="true" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  </script>
</body>
</html>
